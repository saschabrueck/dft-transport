Index: pw_poisson_read_input.F
===================================================================
--- pw_poisson_read_input.F	(revision 14892)
+++ pw_poisson_read_input.F	(working copy)
@@ -19,20 +19,18 @@
                                              use_perd_y,&
                                              use_perd_yz,&
                                              use_perd_z
-  USE input_section_types,             ONLY: section_vals_get_subs_vals,&
+  USE input_section_types,             ONLY: section_vals_get,&
+                                             section_vals_get_subs_vals,&
                                              section_vals_type,&
                                              section_vals_val_get
+  USE kinds,                           ONLY: dp
   USE ps_wavelet_types,                ONLY: WAVELET0D,&
                                              WAVELET2D,&
                                              WAVELET3D
-  USE pw_poisson_types,                ONLY: do_ewald_none,&
-                                             pw_poisson_analytic,&
-                                             pw_poisson_mt,&
-                                             pw_poisson_multipole,&
-                                             pw_poisson_none,&
-                                             pw_poisson_parameter_type,&
-                                             pw_poisson_periodic,&
-                                             pw_poisson_wavelet
+  USE pw_poisson_types,                ONLY: &
+       do_ewald_none, pw_poisson_analytic, pw_poisson_implicit, &
+       pw_poisson_mt, pw_poisson_multipole, pw_poisson_none, &
+       pw_poisson_parameter_type, pw_poisson_periodic, pw_poisson_wavelet
 #include "./common/cp_common_uses.f90"
 
   IMPLICIT NONE
@@ -81,6 +79,7 @@
          CALL decode_periodic_green(periodic, params, error)
       CASE(pw_poisson_wavelet)
          CALL decode_periodic_wavelet(periodic, params, error)
+      CASE(pw_poisson_implicit)
       CASE(pw_poisson_none)
       CASE default
          CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
@@ -103,9 +102,12 @@
     ! parsing WAVELET subsection
     wavelet_section => section_vals_get_subs_vals(poisson_section,"WAVELET",error=error)
     CALL section_vals_val_get(wavelet_section,"SCF_TYPE",i_val=params%wavelet_scf_type,error=error)
+
+    ! parsing IMPLICIT subsection
+    CALL ps_implicit_read_parameters(poisson_section, params, error)
+
   END SUBROUTINE pw_poisson_read_parameters
 
-
 ! *****************************************************************************
 !> \brief Helper routien for pw_poisson_read_parameters
 !> \param periodic ...
@@ -195,4 +197,235 @@
 
   END SUBROUTINE decode_periodic_wavelet
 
+! *****************************************************************************
+!> \brief Reads the subsection IMPLICIT and initializes corresponding parameters in
+!>        pw_poisson_parameter_type
+!> \param poisson_section poisson section to be read from input
+!> \param params poisson_env parameters 
+!> \param error  cp2k error 
+!> \par History
+!>      08.2014 created [Hossein Bani-Hashemian]
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE ps_implicit_read_parameters(poisson_section, params, error)
+    TYPE(section_vals_type), POINTER         :: poisson_section
+    TYPE(pw_poisson_parameter_type), &
+      INTENT(INOUT)                          :: params
+    TYPE(cp_error_type), INTENT(inout)       :: error
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'ps_implicit_read_parameters', &
+      routineP = moduleN//':'//routineN
+
+    INTEGER :: i, n_aac_rep, n_aap_rep, n_p_rep, n_xaac_rep, &
+      xaa_cylindrical_apxtyp, xaa_cylindrical_nsides
+    INTEGER, DIMENSION(:), POINTER           :: aa_cuboidal_nprtn, &
+                                                aa_planar_nprtn, &
+                                                planar_nprtn, &
+                                                xaa_cylindrical_nprtn
+    LOGICAL :: aa_cuboidal_explicit, aa_planar_explicit, has_dielectric, &
+      planar_explicit, smooth, xaa_cylindrical_explicit
+    REAL(dp)                                 :: v_D, xaa_cylindrical_brad, &
+                                                zeta
+    REAL(dp), DIMENSION(:), POINTER :: aa_cuboidal_xxtnt, aa_cuboidal_yxtnt, &
+      aa_cuboidal_zxtnt, aa_planar_xxtnt, aa_planar_yxtnt, aa_planar_zxtnt, &
+      planar_Avtx, planar_Bvtx, planar_Cvtx, planar_Dvtx, &
+      xaa_cylindrical_bctr, xaa_cylindrical_xxtnt
+    TYPE(section_vals_type), POINTER :: aa_cuboidal_section, &
+      aa_planar_section, dbc_section, dielectric_section, planar_section, &
+      ps_implicit_section, xaa_cylindrical_section
+
+    NULLIFY(ps_implicit_section, dielectric_section, dbc_section)
+
+    ! parsing IMPLICIT subsection
+    ps_implicit_section => section_vals_get_subs_vals(poisson_section, "IMPLICIT", error=error)
+    CALL section_vals_val_get(ps_implicit_section, "BOUNDARY_CONDITIONS", &
+                              i_val=params%ps_implicit_params%boundary_condition, error=error)
+    CALL section_vals_val_get(ps_implicit_section, "ZERO_INITIAL_GUESS", &
+                              l_val=params%ps_implicit_params%zero_initial_guess, error=error)
+    CALL section_vals_val_get(ps_implicit_section, "max_iter", i_val=params%ps_implicit_params%max_iter, error=error)
+    CALL section_vals_val_get(ps_implicit_section, "tol", r_val=params%ps_implicit_params%tol, error=error)
+    CALL section_vals_val_get(ps_implicit_section, "omega", r_val=params%ps_implicit_params%omega, error=error)
+
+    ! parsing DIELECTRIC subsection
+    dielectric_section => section_vals_get_subs_vals(ps_implicit_section, "DIELECTRIC", error=error)
+    CALL section_vals_get(dielectric_section, explicit=has_dielectric, error=error)
+    CALL section_vals_val_get(dielectric_section, "eps0", r_val=params%dielectric_params%eps0, error=error)
+    CALL section_vals_val_get(dielectric_section, "rho_min", r_val=params%dielectric_params%rho_min, error=error)
+    CALL section_vals_val_get(dielectric_section, "rho_max", r_val=params%dielectric_params%rho_max, error=error)
+    CALL section_vals_val_get(dielectric_section, "DERIVATIVE_METHOD", &
+                              i_val=params%dielectric_params%derivative_method, error=error)
+    params%has_dielectric = has_dielectric
+
+    ! parsing DIRICHLET_BC subsection
+    dbc_section => section_vals_get_subs_vals(ps_implicit_section, "DIRICHLET_BC", error=error)
+    aa_planar_section => section_vals_get_subs_vals(dbc_section, "AA_PLANAR", error=error)
+    planar_section => section_vals_get_subs_vals(dbc_section, "PLANAR", error=error)
+    xaa_cylindrical_section => section_vals_get_subs_vals(dbc_section, "XAA_CYLINDRICAL", error=error)
+    aa_cuboidal_section => section_vals_get_subs_vals(dbc_section, "AA_CUBOIDAL", error=error)
+    CALL section_vals_get(aa_planar_section, explicit=aa_planar_explicit, n_repetition=n_aap_rep, error=error)
+    CALL section_vals_get(planar_section, explicit=planar_explicit, n_repetition=n_p_rep, error=error)
+    CALL section_vals_get(xaa_cylindrical_section, explicit=xaa_cylindrical_explicit, n_repetition=n_xaac_rep, error=error)
+    CALL section_vals_get(aa_cuboidal_section, explicit=aa_cuboidal_explicit, n_repetition=n_aac_rep, error=error)
+    IF (params%solver .EQ. pw_poisson_implicit) THEN
+       IF (aa_planar_explicit) THEN
+          params%dbc_params%n_aa_planar = n_aap_rep
+          ALLOCATE(params%dbc_params%aa_planar_xxtnt(2, n_aap_rep), &
+                   params%dbc_params%aa_planar_yxtnt(2, n_aap_rep), &
+                   params%dbc_params%aa_planar_zxtnt(2, n_aap_rep), &
+                   params%dbc_params%aa_planar_nprtn(3, n_aap_rep), &
+                   params%dbc_params%aa_planar_vD(n_aap_rep),&
+                   params%dbc_params%aa_planar_zeta(n_aap_rep),&
+                   params%dbc_params%aa_planar_smooth(n_aap_rep))
+          NULLIFY(aa_planar_xxtnt, aa_planar_yxtnt, aa_planar_zxtnt, aa_planar_nprtn)
+          DO i = 1, n_aap_rep
+             CALL section_vals_val_get(aa_planar_section,"v_D"      ,&
+                                       i_rep_section=i,r_val=v_D,error=error)
+             CALL section_vals_val_get(aa_planar_section,"zeta"     ,&
+                                       i_rep_section=i,r_val=zeta,error=error)
+             CALL section_vals_val_get(aa_planar_section,"smooth"   ,&
+                                       i_rep_section=i,l_val=smooth,error=error)
+             CALL section_vals_val_get(aa_planar_section,"X_extents",&
+                                       i_rep_section=i,r_vals=aa_planar_xxtnt,error=error)
+             CALL section_vals_val_get(aa_planar_section,"Y_extents",&
+                                       i_rep_section=i,r_vals=aa_planar_yxtnt,error=error)
+             CALL section_vals_val_get(aa_planar_section,"Z_extents",&
+                                       i_rep_section=i,r_vals=aa_planar_zxtnt,error=error)
+             CALL section_vals_val_get(aa_planar_section,"n_prtn"   ,&
+                                       i_rep_section=i,i_vals=aa_planar_nprtn,error=error)
+             params%dbc_params%aa_planar_vD(i) = v_D
+             params%dbc_params%aa_planar_zeta(i) = zeta
+             params%dbc_params%aa_planar_smooth(i) = smooth
+             params%dbc_params%aa_planar_xxtnt(:,i) = aa_planar_xxtnt
+             params%dbc_params%aa_planar_yxtnt(:,i) = aa_planar_yxtnt
+             params%dbc_params%aa_planar_zxtnt(:,i) = aa_planar_zxtnt
+             params%dbc_params%aa_planar_nprtn(:,i) = aa_planar_nprtn
+          END DO
+       ELSE
+         params%dbc_params%n_aa_planar = 0
+       END IF
+       IF (planar_explicit) THEN
+          params%dbc_params%n_planar = n_p_rep
+          ALLOCATE(params%dbc_params%planar_Avtx(3, n_p_rep), &
+                   params%dbc_params%planar_Bvtx(3, n_p_rep), &
+                   params%dbc_params%planar_Cvtx(3, n_p_rep), &
+                   params%dbc_params%planar_Dvtx(3, n_p_rep), &
+                   params%dbc_params%planar_nprtn(3, n_p_rep), &
+                   params%dbc_params%planar_vD(n_p_rep), &
+                   params%dbc_params%planar_zeta(n_p_rep), &
+                   params%dbc_params%planar_smooth(n_p_rep))
+          NULLIFY(planar_Avtx, planar_Bvtx, planar_Cvtx, planar_Dvtx, planar_nprtn)
+          DO i = 1, n_p_rep
+             CALL section_vals_val_get(planar_section,"v_D"   ,&
+                                       i_rep_section=i,r_val=v_D,error=error)
+             CALL section_vals_val_get(planar_section,"zeta"  ,&
+                                       i_rep_section=i,r_val=zeta,error=error)
+             CALL section_vals_val_get(planar_section,"smooth",&
+                                       i_rep_section=i,l_val=smooth,error=error)
+             CALL section_vals_val_get(planar_section,"A"     ,&
+                                       i_rep_section=i,r_vals=planar_Avtx,error=error)
+             CALL section_vals_val_get(planar_section,"B"     ,&
+                                       i_rep_section=i,r_vals=planar_Bvtx,error=error)
+             CALL section_vals_val_get(planar_section,"C"     ,&
+                                       i_rep_section=i,r_vals=planar_Cvtx,error=error)
+             CALL section_vals_val_get(planar_section,"D"     ,&
+                                       i_rep_section=i,r_vals=planar_Dvtx,error=error)
+             CALL section_vals_val_get(planar_section,"n_prtn",&
+                                       i_rep_section=i,i_vals=planar_nprtn,error=error)
+             params%dbc_params%planar_vD(i) = v_D
+             params%dbc_params%planar_zeta(i) = zeta
+             params%dbc_params%planar_smooth(i) = smooth
+             params%dbc_params%planar_Avtx(:,i) = planar_Avtx
+             params%dbc_params%planar_Bvtx(:,i) = planar_Bvtx
+             params%dbc_params%planar_Cvtx(:,i) = planar_Cvtx
+             params%dbc_params%planar_Dvtx(:,i) = planar_Dvtx
+             params%dbc_params%planar_nprtn(:,i) = planar_nprtn
+          END DO
+       ELSE
+          params%dbc_params%n_planar = 0
+       END IF
+       IF (xaa_cylindrical_explicit) THEN
+          params%dbc_params%n_xaa_cylindrical = n_xaac_rep
+          ALLOCATE(params%dbc_params%xaa_cylindrical_xxtnt(2, n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_nprtn(3, n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_bctr(2, n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_brad(n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_nsides(n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_apxtyp(n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_vD(n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_zeta(n_xaac_rep), &
+                   params%dbc_params%xaa_cylindrical_smooth(n_xaac_rep))
+          NULLIFY(xaa_cylindrical_xxtnt, xaa_cylindrical_bctr, xaa_cylindrical_nprtn)
+          DO i = 1, n_xaac_rep
+             CALL section_vals_val_get(xaa_cylindrical_section,"v_D"        ,&
+                                       i_rep_section=i,r_val=v_D,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"zeta"       ,&
+                                       i_rep_section=i,r_val=zeta,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"smooth"     ,&
+                                       i_rep_section=i,l_val=smooth,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"X_extents"  ,&
+                                       i_rep_section=i,r_vals=xaa_cylindrical_xxtnt,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"base_center",&
+                                       i_rep_section=i,r_vals=xaa_cylindrical_bctr,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"base_radius",&
+                                       i_rep_section=i,r_val=xaa_cylindrical_brad,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"n_sides"    ,&
+                                       i_rep_section=i,i_val=xaa_cylindrical_nsides,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"apx_type"   ,&
+                                       i_rep_section=i,i_val=xaa_cylindrical_apxtyp,error=error)
+             CALL section_vals_val_get(xaa_cylindrical_section,"n_prtn"     ,&
+                                       i_rep_section=i,i_vals=xaa_cylindrical_nprtn,error=error)
+             params%dbc_params%xaa_cylindrical_vD(i) = v_D
+             params%dbc_params%xaa_cylindrical_zeta(i) = zeta
+             params%dbc_params%xaa_cylindrical_smooth(i) = smooth
+             params%dbc_params%xaa_cylindrical_xxtnt(:,i) = xaa_cylindrical_xxtnt
+             params%dbc_params%xaa_cylindrical_bctr(:,i)  = xaa_cylindrical_bctr
+             params%dbc_params%xaa_cylindrical_brad(i)    = xaa_cylindrical_brad
+             params%dbc_params%xaa_cylindrical_nsides(i)  = xaa_cylindrical_nsides
+             params%dbc_params%xaa_cylindrical_apxtyp(i)  = xaa_cylindrical_apxtyp
+             params%dbc_params%xaa_cylindrical_nprtn(:,i) = xaa_cylindrical_nprtn
+          END DO
+       ELSE
+          params%dbc_params%n_xaa_cylindrical = 0
+          ALLOCATE(params%dbc_params%xaa_cylindrical_nsides(n_xaac_rep))
+       END IF
+       IF (aa_cuboidal_explicit) THEN
+          params%dbc_params%n_aa_cuboidal = n_aac_rep
+          ALLOCATE(params%dbc_params%aa_cuboidal_xxtnt(2, n_aac_rep), &
+                   params%dbc_params%aa_cuboidal_yxtnt(2, n_aac_rep), &
+                   params%dbc_params%aa_cuboidal_zxtnt(2, n_aac_rep), &
+                   params%dbc_params%aa_cuboidal_nprtn(3, n_aac_rep), &
+                   params%dbc_params%aa_cuboidal_vD(n_aac_rep),&
+                   params%dbc_params%aa_cuboidal_zeta(n_aac_rep),&
+                   params%dbc_params%aa_cuboidal_smooth(n_aac_rep))
+          NULLIFY(aa_cuboidal_xxtnt, aa_cuboidal_yxtnt, aa_cuboidal_zxtnt, aa_cuboidal_nprtn)
+          DO i = 1, n_aac_rep
+             CALL section_vals_val_get(aa_cuboidal_section,"v_D"      ,&
+                                       i_rep_section=i,r_val=v_D,error=error)
+             CALL section_vals_val_get(aa_cuboidal_section,"zeta"     ,&
+                                       i_rep_section=i,r_val=zeta,error=error)
+             CALL section_vals_val_get(aa_cuboidal_section,"smooth"   ,&
+                                       i_rep_section=i,l_val=smooth,error=error)
+             CALL section_vals_val_get(aa_cuboidal_section,"X_extents",&
+                                       i_rep_section=i,r_vals=aa_cuboidal_xxtnt,error=error)
+             CALL section_vals_val_get(aa_cuboidal_section,"Y_extents",&
+                                       i_rep_section=i,r_vals=aa_cuboidal_yxtnt,error=error)
+             CALL section_vals_val_get(aa_cuboidal_section,"Z_extents",&
+                                       i_rep_section=i,r_vals=aa_cuboidal_zxtnt,error=error)
+             CALL section_vals_val_get(aa_cuboidal_section,"n_prtn"   ,&
+                                       i_rep_section=i,i_vals=aa_cuboidal_nprtn,error=error)
+             params%dbc_params%aa_cuboidal_vD(i) = v_D
+             params%dbc_params%aa_cuboidal_zeta(i) = zeta
+             params%dbc_params%aa_cuboidal_smooth(i) = smooth
+             params%dbc_params%aa_cuboidal_xxtnt(:,i) = aa_cuboidal_xxtnt
+             params%dbc_params%aa_cuboidal_yxtnt(:,i) = aa_cuboidal_yxtnt
+             params%dbc_params%aa_cuboidal_zxtnt(:,i) = aa_cuboidal_zxtnt
+             params%dbc_params%aa_cuboidal_nprtn(:,i) = aa_cuboidal_nprtn
+          END DO
+       ELSE
+         params%dbc_params%n_aa_cuboidal = 0
+       END IF
+    END IF
+
+  END SUBROUTINE ps_implicit_read_parameters
+
 END MODULE pw_poisson_read_input
Index: input_cp2k_dft.F
===================================================================
--- input_cp2k_dft.F	(revision 14892)
+++ input_cp2k_dft.F	(working copy)
@@ -1656,6 +1656,25 @@
        CALL section_add_subsection(section,print_key,error=error)
        CALL section_release(print_key,error=error)
 
+       ! dielectric constant function
+       CALL cp_print_key_section_create(print_key,"dielectric_cube",&
+            description="", &
+            print_level=high_print_level,filename="",&
+            error=error)
+       CALL keyword_create(keyword, name="stride",&
+            description="",&
+            usage="STRIDE 2 2 2",n_var=-1,default_i_vals=(/2,2,2/), type_of_var=integer_t,error=error)
+       CALL section_add_keyword(print_key,keyword,error=error)
+       CALL keyword_release(keyword,error=error)
+       CALL keyword_create(keyword, name="APPEND",&
+            description="",&
+            default_l_val=.FALSE., lone_keyword_l_val=.TRUE.,error=error)
+       CALL section_add_keyword(print_key,keyword,error=error)
+       CALL keyword_release(keyword,error=error)
+
+       CALL section_add_subsection(section,print_key,error=error)
+       CALL section_release(print_key,error=error)
+
 ! ZMP adding the print section for  the v_xc cube 
        CALL cp_print_key_section_create(print_key,"v_xc_cube",&
             description="Controls the printing of a cube file with xc "//&
Index: pw_env_methods.F
===================================================================
--- pw_env_methods.F	(revision 14892)
+++ pw_env_methods.F	(working copy)
@@ -28,6 +28,10 @@
                                              init_cube_info,&
                                              return_cube_max_iradius
   USE d3_poly,                         ONLY: init_d3_poly_module
+  USE dct,                             ONLY: setup_dct_pw_grids
+  USE dielectric_types,                ONLY: derivative_cd3,&
+                                             derivative_cd5,&
+                                             derivative_cd7
   USE gaussian_gridlevels,             ONLY: destroy_gaussian_gridlevel,&
                                              gaussian_gridlevel,&
                                              init_gaussian_gridlevel
@@ -40,6 +44,9 @@
   USE kinds,                           ONLY: dp
   USE lgrid_types,                     ONLY: lgrid_create,&
                                              lgrid_release
+  USE ps_implicit_types,               ONLY: MIXED_BC,&
+                                             MIXED_PERIODIC_BC,&
+                                             PERIODIC_BC
   USE ps_wavelet_types,                ONLY: WAVELET0D,&
                                              WAVELET2D,&
                                              WAVELET3D
@@ -55,14 +62,10 @@
                                              pw_grid_setup
   USE pw_poisson_methods,              ONLY: pw_poisson_set
   USE pw_poisson_read_input,           ONLY: pw_poisson_read_parameters
-  USE pw_poisson_types,                ONLY: pw_poisson_analytic,&
-                                             pw_poisson_create,&
-                                             pw_poisson_mt,&
-                                             pw_poisson_multipole,&
-                                             pw_poisson_none,&
-                                             pw_poisson_parameter_type,&
-                                             pw_poisson_periodic,&
-                                             pw_poisson_wavelet
+  USE pw_poisson_types,                ONLY: &
+       pw_poisson_analytic, pw_poisson_create, pw_poisson_implicit, &
+       pw_poisson_mt, pw_poisson_multipole, pw_poisson_none, &
+       pw_poisson_parameter_type, pw_poisson_periodic, pw_poisson_wavelet
   USE pw_pool_types,                   ONLY: pw_pool_create,&
                                              pw_pool_p_type,&
                                              pw_pool_release,&
@@ -75,14 +78,11 @@
                                              qs_kind_type
   USE qs_rho0_types,                   ONLY: get_rho0_mpole,&
                                              rho0_mpole_type
-  USE realspace_grid_types,            ONLY: realspace_grid_desc_p_type,&
-                                             realspace_grid_input_type,&
-                                             realspace_grid_p_type,&
-                                             rs_grid_create,&
-                                             rs_grid_create_descriptor,&
-                                             rs_grid_print,&
-                                             rs_grid_release,&
-                                             rs_grid_release_descriptor
+  USE realspace_grid_types,            ONLY: &
+       realspace_grid_desc_p_type, realspace_grid_desc_type, &
+       realspace_grid_input_type, realspace_grid_p_type, realspace_grid_type, &
+       rs_grid_create, rs_grid_create_descriptor, rs_grid_print, &
+       rs_grid_release, rs_grid_release_descriptor, rs_pw_transfer
   USE termination,                     ONLY: stop_program
   USE timings,                         ONLY: timeset,&
                                              timestop
@@ -182,10 +182,9 @@
     TYPE(cp_logger_type), POINTER            :: logger
     TYPE(cp_para_env_type), POINTER          :: para_env
     TYPE(dft_control_type), POINTER          :: dft_control
-    TYPE(pw_grid_type), POINTER              :: mt_super_ref_grid, &
-                                                old_pw_grid, pw_grid, &
-                                                super_ref_grid, vdw_grid, &
-                                                xc_super_ref_grid
+    TYPE(pw_grid_type), POINTER :: dct_aux_pw_grid, dct_pw_grid, &
+      mt_super_ref_grid, old_pw_grid, pw_grid, super_ref_grid, vdw_grid, &
+      xc_super_ref_grid
     TYPE(pw_poisson_parameter_type)          :: poisson_params
     TYPE(pw_pool_p_type), DIMENSION(:), &
       POINTER                                :: pw_pools
@@ -217,6 +216,7 @@
   NULLIFY(cutoff, cell, pw_grid, old_pw_grid, dft_control, qs_kind_set, &
        pw_pools, rho0_mpole, rs_descs, para_env, cell_ref, &
        mt_super_ref_grid, input, poisson_section, xc_super_ref_grid, &
+       dct_pw_grid, dct_aux_pw_grid, &
        vdw_grid, super_ref_grid, my_cell, rs_grids, dispersion_env)
 
   CALL get_qs_env(qs_env=qs_env,&
@@ -515,26 +515,48 @@
      END IF
      poisson_section => section_vals_get_subs_vals(input,"DFT%POISSON",&
           error=error)
+
      CALL pw_poisson_read_parameters(poisson_section, poisson_params, error)
      CALL pw_poisson_set(pw_env%poisson_env,cell_hmat=my_cell%hmat,pw_pools=pw_env%pw_pools,&
           parameters=poisson_params,mt_super_ref_pw_grid=mt_super_ref_grid,&
+          dct_pw_grid=dct_pw_grid, dct_aux_pw_grid=dct_aux_pw_grid,&
           use_level=pw_env%auxbas_grid,error=error)
      CALL pw_grid_release(mt_super_ref_grid,error=error)
+     CALL pw_grid_release(dct_pw_grid,error=error)
+     CALL pw_grid_release(dct_aux_pw_grid,error=error)
 !
 ! If reference cell is present, then use pw_grid_change to keep bounds constant...
 ! do not re-init the Gaussian grid level (fix the gridlevel on which the pgf should go.
 !
-    IF ( use_ref_cell ) THEN
+     IF ( use_ref_cell ) THEN
          DO igrid_level = 1, SIZE ( pw_pools )
            CALL pw_grid_change ( cell%hmat, pw_pools ( igrid_level ) % pool % pw_grid )
          ENDDO
          IF (set_vdw_pool) CALL pw_grid_change( cell%hmat, pw_env%vdw_pw_pool%pw_grid )
          CALL pw_poisson_read_parameters(poisson_section, poisson_params, error)
          CALL pw_poisson_set(pw_env%poisson_env,cell_hmat=cell%hmat,pw_pools=pw_env%pw_pools,&
-          parameters=poisson_params,mt_super_ref_pw_grid=mt_super_ref_grid,&
-          use_level=pw_env%auxbas_grid,error=error)
-    END IF
+                             parameters=poisson_params,mt_super_ref_pw_grid=mt_super_ref_grid,&
+                             dct_pw_grid=dct_pw_grid, dct_aux_pw_grid=dct_aux_pw_grid,&
+                             use_level=pw_env%auxbas_grid,error=error)
+     END IF
 
+     !> setup dct_pw_grid (an extended pw_grid) for Discrete Cosine Transformation (DCT) 
+     IF (poisson_params%ps_implicit_params%boundary_condition .EQ. MIXED_BC) THEN
+        CALL setup_dct_pw_grids(pw_env%poisson_env%pw_pools(pw_env%poisson_env%pw_level)%pool%pw_grid,&
+                            my_cell%hmat, &
+                            pw_env%poisson_env%dct_pw_grid, pw_env%poisson_env%dct_aux_pw_grid, error)
+     END IF
+     !> setup real space grid for finite difference derivatives of dielectric constant function
+     IF ( poisson_params%has_dielectric .AND. &
+        ((poisson_params%dielectric_params%derivative_method .EQ. derivative_cd3) .OR. &
+         (poisson_params%dielectric_params%derivative_method .EQ. derivative_cd5) .OR. &
+         (poisson_params%dielectric_params%derivative_method .EQ. derivative_cd7))) THEN
+        CALL setup_diel_rs_grid(pw_env%poisson_env%diel_rs_grid, &
+                            poisson_params%dielectric_params%derivative_method, input, &
+                            pw_env%poisson_env%pw_pools(pw_env%poisson_env%pw_level)%pool%pw_grid,&
+                            error)
+     END IF
+
 !
 !
 !    determine the maximum radii for mapped gaussians, needed to
@@ -636,6 +658,24 @@
                              "Invalid periodicity for wavelet solver selected",&
                              para_env)
          END SELECT
+       CASE(pw_poisson_implicit)
+         WRITE (UNIT=iounit,FMT="(/,T2,A,T51,A30)")&
+          "POISSON| Solver","IMPLICIT (ITERATIVE)"
+         SELECT CASE (poisson_params%ps_implicit_params%boundary_condition)
+         CASE (PERIODIC_BC)
+           WRITE (UNIT=iounit,FMT="(T2,A,T51,A30)")&
+            "POISSON| Boundary Condition","PERIODIC"
+         CASE (MIXED_BC)
+           WRITE (UNIT=iounit,FMT="(T2,A,T51,A30)")&
+            "POISSON| Boundary Condition","MIXED"
+         CASE (MIXED_PERIODIC_BC)
+           WRITE (UNIT=iounit,FMT="(T2,A,T51,A30)")&
+            "POISSON| Boundary Condition","PERIODIC & DIRICHLET"
+         CASE DEFAULT
+           CALL stop_program(routineN,moduleN,__LINE__,&
+                  "Invalid boundary conditions for the implicit (iterative) poisson solver.",&
+                  para_env)
+         END SELECT
        CASE(pw_poisson_none)
          WRITE (UNIT=iounit,FMT="(/,T2,A,T51,A30)")&
           "POISSON| Solver","NONE"
@@ -644,7 +684,8 @@
                            "Invalid Poisson solver selected",&
                            para_env)
        END SELECT
-       IF (poisson_params%solver /= pw_poisson_wavelet) THEN
+       IF ((poisson_params%solver .NE. pw_poisson_wavelet) .AND. &
+           (poisson_params%solver .NE. pw_poisson_implicit)) THEN
          IF (SUM(poisson_params%periodic(1:3)) == 0) THEN
            WRITE (UNIT=iounit,FMT="(T2,A,T51,A30)")&
             "POISSON| Periodicity","NONE"
@@ -989,5 +1030,56 @@
     END IF
   END SUBROUTINE setup_super_ref_grid
 
+! *****************************************************************************
+!> \brief   sets up a real-space grid for finite difference derivative of dielectric 
+!>          constant function
+!> \param diel_rs_grid real space grid to be created
+!> \param method preferred finite difference derivative method 
+!> \param input input file
+!> \param pw_grid plane-wave grid
+!> \param error cp2k error
+!> \par History
+!>       12.2014 created [Hossein Bani-Hashemian]
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE setup_diel_rs_grid(diel_rs_grid, method, input, pw_grid, error)
+
+    TYPE(realspace_grid_type), POINTER       :: diel_rs_grid
+    INTEGER, INTENT(IN)                      :: method
+    TYPE(section_vals_type), POINTER         :: input
+    TYPE(pw_grid_type), POINTER              :: pw_grid
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(LEN=*), PARAMETER :: routineN = 'setup_diel_rs_grid', &
+      routineP = moduleN//':'//routineN
+
+    INTEGER                                  :: border_points, handle
+    TYPE(realspace_grid_desc_type), POINTER  :: rs_desc
+    TYPE(realspace_grid_input_type)          :: input_settings
+    TYPE(section_vals_type), POINTER         :: rs_grid_section
+
+    CALL timeset(routineN,handle)
+
+    NULLIFY (rs_desc)
+    rs_grid_section => section_vals_get_subs_vals(input,"DFT%MGRID%RS_GRID",error=error)
+    SELECT CASE (method)
+    CASE (derivative_cd3)
+      border_points = 1
+    CASE (derivative_cd5)
+      border_points = 2
+    CASE (derivative_cd7)
+      border_points = 3
+    END SELECT
+    CALL init_input_type(input_settings,2*border_points+1,rs_grid_section,&
+                         1,(/-1,-1,-1/),error)
+    CALL rs_grid_create_descriptor(rs_desc,pw_grid,input_settings,&
+                                   border_points=border_points,error=error)
+    CALL rs_grid_create(diel_rs_grid,rs_desc,error=error) 
+    CALL rs_grid_release_descriptor(rs_desc,error=error)
+
+    CALL timestop(handle)
+
+  END SUBROUTINE setup_diel_rs_grid
+
 END MODULE pw_env_methods
 
Index: qs_sccs.F
===================================================================
--- qs_sccs.F	(revision 14892)
+++ qs_sccs.F	(working copy)
@@ -83,11 +83,17 @@
   USE qs_rho_types,                    ONLY: qs_rho_get,&
                                              qs_rho_type
   USE qs_scf_types,                    ONLY: qs_scf_env_type
-  USE realspace_grid_types,            ONLY: &
-       pw2rs, realspace_grid_desc_type, realspace_grid_input_type, &
-       realspace_grid_p_type, realspace_grid_type, rs2pw, rs_grid_create, &
-       rs_grid_create_descriptor, rs_grid_release, &
-       rs_grid_release_descriptor, rs_grid_zero, rs_pw_transfer
+  USE realspace_grid_cube
+  USE realspace_grid_types,            ONLY: realspace_grid_desc_type,&
+                                             realspace_grid_input_type,&
+                                             realspace_grid_type,&
+                                             rs_grid_create,&
+                                             rs_grid_create_descriptor,&
+                                             rs_grid_release,&
+                                             rs_grid_release_descriptor
+  USE rs_methods,                      ONLY: derive_fdm_cd3,&
+                                             derive_fdm_cd5,&
+                                             derive_fdm_cd7
   USE termination,                     ONLY: print_warning,&
                                              stop_program
   USE timings,                         ONLY: timeset,&
@@ -136,7 +142,8 @@
                                                 my_pos_cube, print_path
     INTEGER                                  :: cube_unit, di, dj, handle, i, &
                                                 ispin, iter, j, k, nspin, &
-                                                output_unit, print_level
+                                                output_unit, print_level, &
+                                                unit_nr
     INTEGER(KIND=int_8)                      :: ngpts
     INTEGER, DIMENSION(3)                    :: lb, ub
     LOGICAL                                  :: append_cube, &
@@ -316,6 +323,13 @@
     CALL mp_sum(tot_rho_elec,para_env%group)
 
     ! Calculate the dielectric (smoothed) function of rho_elec in r-space
+IF (rho_elec%pw_grid%para%rs_mpo == 0) THEN
+   unit_nr = 1
+ELSE
+   unit_nr = -1
+END IF
+CALL pw_to_cube(rho_elec, unit_nr=unit_nr, error=error)
+
     eps_elec => work_r3d(2)%pw
     deps_elec => work_r3d(3)%pw
     eps0 = sccs_control%epsilon_solvent
@@ -996,18 +1010,13 @@
     CHARACTER(LEN=*), PARAMETER :: routineN = 'derive', &
       routineP = moduleN//':'//routineN
 
-    INTEGER                                  :: border_points, handle, i, j, k
+    INTEGER                                  :: border_points, handle, i
     INTEGER, DIMENSION(3)                    :: lb, n, ub
     LOGICAL                                  :: failure
-    REAL(KIND=dp), DIMENSION(3)              :: h
-    REAL(KIND=dp), DIMENSION(:, :, :), &
-      POINTER                                :: drdx, drdy, drdz, r
     TYPE(pw_p_type), DIMENSION(2)            :: work_g1d
     TYPE(pw_pool_type), POINTER              :: auxbas_pw_pool
     TYPE(realspace_grid_desc_type), POINTER  :: rs_desc
     TYPE(realspace_grid_input_type)          :: input_settings
-    TYPE(realspace_grid_p_type), &
-      DIMENSION(3)                           :: drs_grid
     TYPE(realspace_grid_type), POINTER       :: rs_grid
     TYPE(section_vals_type), POINTER         :: rs_grid_section
 
@@ -1039,17 +1048,6 @@
                                      border_points=border_points,error=error)
       CALL rs_grid_create(rs_grid,rs_desc,error=error)
 !MK      CALL rs_grid_print(rs_grid,6,error=error)
-      CALL rs_pw_transfer(rs_grid,f,pw2rs,error=error)
-      DO i=1,3
-        CALL rs_grid_create(drs_grid(i)%rs_grid,rs_desc,error=error)
-        CALL rs_grid_zero(drs_grid(i)%rs_grid)
-      END DO
-      lb(1:3) = rs_grid%lb_real(1:3)
-      ub(1:3) = rs_grid%ub_real(1:3)
-      r => rs_grid%r
-      drdx => drs_grid(1)%rs_grid%r
-      drdy => drs_grid(2)%rs_grid%r
-      drdz => drs_grid(3)%rs_grid%r
     CASE (sccs_derivative_fft)
       lb(1:3) = f%pw_grid%bounds_local(1,1:3)
       ub(1:3) = f%pw_grid%bounds_local(2,1:3)
@@ -1069,56 +1067,11 @@
     ! Calculate the derivatives
     SELECT CASE (method)
     CASE (sccs_derivative_cd3)
-      ! 3-point stencil central differences
-      h(1:3) = 2.0_dp*f%pw_grid%dr(1:3)
-      !$omp parallel do default(none) &
-      !$omp             private(i,j,k) &
-      !$omp             shared(drdx,drdy,drdz,h,lb,r,ub)
-      DO k=lb(3),ub(3)
-        DO j=lb(2),ub(2)
-          DO i=lb(1),ub(1)
-            drdx(i,j,k) = (r(i+1,j,k) - r(i-1,j,k))/h(1)
-            drdy(i,j,k) = (r(i,j+1,k) - r(i,j-1,k))/h(2)
-            drdz(i,j,k) = (r(i,j,k+1) - r(i,j,k-1))/h(3)
-          END DO
-        END DO
-      END DO
-      !$omp end parallel do
+      CALL derive_fdm_cd3(f,df,rs_grid,error)
     CASE (sccs_derivative_cd5)
-      ! 5-point stencil central differences
-      h(1:3) = 12.0_dp*f%pw_grid%dr(1:3)
-      !$omp parallel do default(none) &
-      !$omp             private(i,j,k) &
-      !$omp             shared(drdx,drdy,drdz,h,lb,r,ub)
-      DO k=lb(3),ub(3)
-        DO j=lb(2),ub(2)
-          DO i=lb(1),ub(1)
-            drdx(i,j,k) = (r(i-2,j,k) - r(i+2,j,k) + 8.0_dp*(r(i+1,j,k) - r(i-1,j,k)))/h(1)
-            drdy(i,j,k) = (r(i,j-2,k) - r(i,j+2,k) + 8.0_dp*(r(i,j+1,k) - r(i,j-1,k)))/h(2)
-            drdz(i,j,k) = (r(i,j,k-2) - r(i,j,k+2) + 8.0_dp*(r(i,j,k+1) - r(i,j,k-1)))/h(3)
-          END DO
-        END DO
-      END DO
-      !$omp end parallel do
-    CASE (sccs_derivative_cd7)
-      ! 7-point stencil central differences
-      h(1:3) = 60.0_dp*f%pw_grid%dr(1:3)
-      !$omp parallel do default(none) &
-      !$omp             private(i,j,k) &
-      !$omp             shared(drdx,drdy,drdz,h,lb,r,ub)
-      DO k=lb(3),ub(3)
-        DO j=lb(2),ub(2)
-          DO i=lb(1),ub(1)
-            drdx(i,j,k) = (r(i+3,j,k) - r(i-3,j,k) + 9.0_dp*(r(i-2,j,k) - r(i+2,j,k)) +&
-                           45.0_dp*(r(i+1,j,k) - r(i-1,j,k)))/h(1)
-            drdy(i,j,k) = (r(i,j+3,k) - r(i,j-3,k) + 9.0_dp*(r(i,j-2,k) - r(i,j+2,k)) +&
-                           45.0_dp*(r(i,j+1,k) - r(i,j-1,k)))/h(2)
-            drdz(i,j,k) = (r(i,j,k+3) - r(i,j,k-3) + 9.0_dp*(r(i,j,k-2) - r(i,j,k+2)) +&
-                           45.0_dp*(r(i,j,k+1) - r(i,j,k-1)))/h(3)
-          END DO
-        END DO
-      END DO
-      !$omp end parallel do
+      CALL derive_fdm_cd5(f,df,rs_grid,error)
+    CASE (sccs_derivative_cd7)     
+      CALL derive_fdm_cd7(f,df,rs_grid,error)
     CASE (sccs_derivative_fft)
       ! FFT
       CALL pw_transfer(f,work_g1d(1)%pw,error=error)
@@ -1139,10 +1092,6 @@
     SELECT CASE (method)
     CASE (sccs_derivative_cd3,sccs_derivative_cd5,sccs_derivative_cd7)
       CALL rs_grid_release(rs_grid,error=error)
-      DO i=1,3
-        CALL rs_pw_transfer(drs_grid(i)%rs_grid,df(i)%pw,rs2pw,error=error)
-        CALL rs_grid_release(drs_grid(i)%rs_grid,error=error)
-      END DO
       CALL rs_grid_release_descriptor(rs_desc,error=error)
     CASE (sccs_derivative_fft)
       DO i=1,SIZE(work_g1d)
Index: qs_scf_post_gpw.F
===================================================================
--- qs_scf_post_gpw.F	(revision 14892)
+++ qs_scf_post_gpw.F	(working copy)
@@ -105,6 +105,7 @@
                                              pw_scale,&
                                              pw_transfer,&
                                              pw_zero
+  USE pw_poisson_types,                ONLY: pw_poisson_type
   USE pw_pool_types,                   ONLY: pw_pool_create_pw,&
                                              pw_pool_give_back_pw,&
                                              pw_pool_p_type,&
@@ -2289,8 +2290,9 @@
     CHARACTER(LEN=default_string_length)     :: name
     INTEGER :: handle, i, iat, id, ikind, iso, ispin, istat, iw, l, nd(3), &
       ngto, niso, nkind, np, nr, output_unit, print_level, unit_nr
-    LOGICAL :: append_cube, failure, print_it, print_total_density, &
-      rho_r_valid, write_ks, write_xc, xrd_interface
+    LOGICAL :: append_cube, do_dielectric_cube, failure, has_dielectric, &
+      print_it, print_total_density, rho_r_valid, write_ks, write_xc, &
+      xrd_interface
     REAL(KIND=dp)                            :: q_max, rho_hard, rho_soft, &
                                                 rho_total, rho_total_rspace, &
                                                 udvol, volume
@@ -2319,6 +2321,7 @@
                                                 rho_elec_rspace, wf_r
     TYPE(pw_p_type), DIMENSION(:), POINTER   :: rho_r
     TYPE(pw_p_type), POINTER                 :: rho0_s_gs, rho_core, vee
+    TYPE(pw_poisson_type), POINTER           :: poisson_env
     TYPE(pw_pool_p_type), DIMENSION(:), &
       POINTER                                :: pw_pools
     TYPE(pw_pool_type), POINTER              :: auxbas_pw_pool
@@ -2331,7 +2334,8 @@
     TYPE(rho_atom_type), DIMENSION(:), &
       POINTER                                :: rho_atom_set
     TYPE(rho_atom_type), POINTER             :: rho_atom
-    TYPE(section_vals_type), POINTER         :: dft_section, input, &
+    TYPE(section_vals_type), POINTER         :: dft_section, &
+                                                dielectric_section, input, &
                                                 print_key, xc_section
 
     CALL timeset(routineN,handle)
@@ -2827,6 +2831,33 @@
           CALL pw_pool_give_back_pw(auxbas_pw_pool,aux_g%pw, error=error)
        END IF
 
+       ! Write the dielectric constant into a cube file
+       do_dielectric_cube = BTEST(cp_print_key_should_output(logger%iter_info,input,&
+                                  "DFT%PRINT%DIELECTRIC_CUBE",error=error),cp_p_file)
+       dielectric_section => section_vals_get_subs_vals(input,"DFT%POISSON%IMPLICIT%DIELECTRIC",error=error)
+       CALL section_vals_get(dielectric_section,explicit=has_dielectric,error=error)
+
+       IF (has_dielectric .AND. do_dielectric_cube) THEN
+          append_cube = section_get_lval(input,"DFT%PRINT%DIELECTRIC_CUBE%APPEND",error=error)
+          my_pos_cube="REWIND"
+          IF(append_cube) THEN
+             my_pos_cube="APPEND"
+          END IF
+          unit_nr=cp_print_key_unit_nr(logger,input,"DFT%PRINT%DIELECTRIC_CUBE",&
+               extension=".cube", middle_name="DIELCTRIC_CONSTANT", file_position=my_pos_cube, error=error)
+          CALL get_qs_env(qs_env=qs_env, pw_env=pw_env, error=error)
+          CALL pw_env_get(pw_env, poisson_env=poisson_env, auxbas_pw_pool=auxbas_pw_pool, error=error)
+          CALL pw_pool_create_pw(auxbas_pw_pool, aux_r%pw, use_data=REALDATA3D, in_space=REALSPACE, error=error)
+
+          CALL pw_copy(poisson_env%implicit_env%dielectric%eps, aux_r%pw, error=error)
+
+          CALL cp_pw_to_cube(aux_r%pw, unit_nr, "DIELECTRIC CONSTANT", particles=particles,&
+               stride=section_get_ivals(dft_section, "PRINT%DIELECTRIC_CUBE%STRIDE", error=error), error=error)
+          CALL cp_print_key_finished_output(unit_nr, logger, input, "DFT%PRINT%DIELECTRIC_CUBE", error=error)
+
+          CALL pw_pool_give_back_pw(auxbas_pw_pool, aux_r%pw, error=error)
+       ENDIF
+
        ! Write the density matrices
        IF (BTEST(cp_print_key_should_output(logger%iter_info,input,&
                  "DFT%PRINT%AO_MATRICES/DENSITY",error=error),cp_p_file)) THEN
Index: input_cp2k_poisson.F
===================================================================
--- input_cp2k_poisson.F	(revision 14892)
+++ input_cp2k_poisson.F	(working copy)
@@ -26,6 +26,14 @@
                                              low_print_level,&
                                              medium_print_level
   USE cp_units,                        ONLY: cp_unit_to_cp2k
+  USE dielectric_types,                ONLY: derivative_cd3,&
+                                             derivative_cd5,&
+                                             derivative_cd7,&
+                                             derivative_fft,&
+                                             derivative_fft_use_deps,&
+                                             derivative_fft_use_drho
+  USE dirichlet_bc_types,              ONLY: CIRCUMSCRIBED,&
+                                             INSCRIBED
   USE input_constants,                 ONLY: do_fist_pol_cg,&
                                              do_fist_pol_none,&
                                              do_fist_pol_sc
@@ -46,10 +54,13 @@
                                              do_multipole_dipole,&
                                              do_multipole_none,&
                                              do_multipole_quadrupole
+  USE ps_implicit_types,               ONLY: MIXED_BC,&
+                                             MIXED_PERIODIC_BC,&
+                                             PERIODIC_BC
   USE pw_poisson_types,                ONLY: &
        do_ewald_ewald, do_ewald_none, do_ewald_pme, do_ewald_spme, &
-       pw_poisson_analytic, pw_poisson_mt, pw_poisson_multipole, &
-       pw_poisson_periodic, pw_poisson_wavelet
+       pw_poisson_analytic, pw_poisson_implicit, pw_poisson_mt, &
+       pw_poisson_multipole, pw_poisson_periodic, pw_poisson_wavelet
   USE pw_spline_utils,                 ONLY: no_precond,&
                                              precond_spl3_1,&
                                              precond_spl3_2,&
@@ -103,8 +114,9 @@
             variants=(/"POISSON", "PSOLVER"/),&
             description="Specify which kind of solver to use to solve the Poisson equation.",&
             usage="POISSON_SOLVER char",&
-            enum_c_vals=s2a( "PERIODIC", "ANALYTIC", "MT", "MULTIPOLE","WAVELET"),&
-            enum_i_vals=(/ pw_poisson_periodic, pw_poisson_analytic, pw_poisson_mt, pw_poisson_multipole,pw_poisson_wavelet/),&
+            enum_c_vals=s2a( "PERIODIC", "ANALYTIC", "MT", "MULTIPOLE", "WAVELET", "IMPLICIT" ),&
+            enum_i_vals=(/ pw_poisson_periodic, pw_poisson_analytic, pw_poisson_mt, pw_poisson_multipole, &
+                           pw_poisson_wavelet, pw_poisson_implicit/),&
             citations=(/Blochl1995,Martyna1999,Genovese2006,Genovese2007/),&
             default_i_val=pw_poisson_periodic, error=error)
        CALL section_add_keyword(section,keyword,error=error)
@@ -140,6 +152,13 @@
        CALL section_add_subsection(section, subsection, error=error)
        CALL section_release(subsection,error=error)
 
+       CALL create_dielectric_section(subsection,error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection,error=error)
+
+       CALL create_implicit_ps_section(subsection,error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection,error=error)
     END IF
   END SUBROUTINE create_poisson_section
 
@@ -601,4 +620,521 @@
     END IF
   END SUBROUTINE create_wavelet_section
 
+! *****************************************************************************
+!> \brief Creates the section for the generalized (iterative) poisson solver
+!> \param section the section to be created
+!> \param error cp2k error
+!>
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE create_implicit_ps_section(section,error)
+    TYPE(section_type), POINTER              :: section
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'create_implicit_ps_section', &
+      routineP = moduleN//':'//routineN
+
+    LOGICAL                                  :: failure
+    TYPE(keyword_type), POINTER              :: keyword
+    TYPE(section_type), POINTER              :: subsection
+
+    failure=.FALSE.
+
+    CPPrecondition(.NOT.ASSOCIATED(section), cp_failure_level, routineP, error, failure)
+    IF (.NOT. failure) THEN
+       CALL section_create(section,name="IMPLICIT",&
+            description="Parameters for the generalized Poisson solver.",&
+            n_keywords=4, n_subsections=2, repeats=.FALSE., required=.FALSE.,&
+            error=error)
+
+       NULLIFY(subsection, keyword)
+
+       CALL create_dielectric_section(subsection,error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection, error=error)
+
+       CALL create_dbc_section(subsection,error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection, error=error)
+
+       CALL keyword_create(keyword, name="BOUNDARY_CONDITIONS", &
+            enum_c_vals=s2a( 'PERIODIC', 'MIXED', 'MIXED_PERIODIC' ), &
+            enum_i_vals=(/ PERIODIC_BC, MIXED_BC, MIXED_PERIODIC_BC /), &
+            description="Specifies the type of boundary conditions.", &
+            usage="BOUNDARY_CONDITIONS <bc_type>", default_i_val=PERIODIC_BC, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="ZERO_INITIAL_GUESS", &
+            description="Whether or not to use zero potential as initial guess.", &
+            usage="ZERO_INITIAL_GUESS <logical>", default_l_val=.FALSE., error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="max_iter", &
+            description="Maximum number of iterations.", &
+            usage="max_iter <integer>", default_i_val=30, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="tol", &
+            description="Stopping tolerance.", &
+            usage="tol <real>", default_r_val=1.0E-8_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="omega", &
+            description="Over-relaxation parameter.", &
+            usage="omega <real>", default_r_val=1.0_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+    END IF
+  END SUBROUTINE create_implicit_ps_section
+
+! *****************************************************************************
+!> \brief Creates the dielectric constant section.
+!>  The dielectric constant is defined as a function of electronic density.
+!>  [see O. Andreussi, I. Dabo, and N. Marzari, J. Chem. Phys., 136, 064102(2012)]
+!> \param section the section to be created
+!> \param error cp2k error
+!>
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE create_dielectric_section(section,error)
+    TYPE(section_type), POINTER              :: section
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'create_dielectric_section', &
+      routineP = moduleN//':'//routineN
+
+    LOGICAL                                  :: failure
+    TYPE(keyword_type), POINTER              :: keyword
+
+    failure=.FALSE.
+
+    CPPrecondition(.NOT.ASSOCIATED(section), cp_failure_level, routineP, error, failure)
+    IF (.NOT. failure) THEN
+       CALL section_create(section,name="DIELECTRIC", &
+            description="Parameters for the self-consistent continuum solvation model.", &
+            n_keywords=4, n_subsections=0, repeats=.FALSE., required=.FALSE., &
+            error=error)
+
+       NULLIFY(keyword)
+
+       CALL keyword_create(keyword, name="eps0", &
+            description="Dielectric constant in the bulk of the solvent.", &
+            usage="eps0 <real>", default_r_val=80.0_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="rho_min", &
+            description="Lower density threshold.", &
+            usage="rho_min <real>", default_r_val=1.0E-4_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="rho_max", &
+            description="Upper density threshold.", &
+            usage="rho_max <real>", default_r_val=1.0E-3_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="DERIVATIVE_METHOD", &
+            enum_c_vals=s2a('fft', 'fft_use_deps', 'fft_use_drho', 'cd3', 'cd5', 'cd7'), &
+            enum_i_vals=(/ derivative_fft, derivative_fft_use_deps, derivative_fft_use_drho, &
+                           derivative_cd3, derivative_cd5, derivative_cd7 /), &
+            description="Preferred method for evaluating the gradient of ln(eps).", &
+            usage="DERIVATIVE_METHOD  <method>", default_i_val=derivative_fft_use_deps, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+    END IF
+
+  END SUBROUTINE create_dielectric_section
+
+! *****************************************************************************
+!> \brief Creates the section for Dirichlet boundary conditions
+!> \param section the section to be created
+!> \param error cp2k error
+!>
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE create_dbc_section(section,error)
+    TYPE(section_type), POINTER              :: section
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'create_dbc_section', &
+      routineP = moduleN//':'//routineN
+
+    LOGICAL                                  :: failure
+    TYPE(section_type), POINTER              :: subsection
+
+    failure=.FALSE.
+
+    CPPrecondition(.NOT.ASSOCIATED(section), cp_failure_level, routineP, error, failure)
+    IF (.NOT. failure) THEN
+       CALL section_create(section,name="DIRICHLET_BC", &
+            description="Parameters for creating Dirichlet type boundary conditions.",&
+            n_keywords=1, n_subsections=4, repeats=.FALSE., required=.FALSE.,&
+            error=error)
+
+       NULLIFY(subsection)
+
+       CALL create_aa_planar_section(subsection, error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection, error=error)
+
+       CALL create_planar_section(subsection, error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection, error=error)
+
+       CALL create_xaa_cylindrical_section(subsection, error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection, error=error)
+
+       CALL create_aa_cuboidal_section(subsection, error)
+       CALL section_add_subsection(section, subsection, error=error)
+       CALL section_release(subsection, error=error)
+
+    END IF
+  END SUBROUTINE create_dbc_section
+
+! *****************************************************************************
+!> \brief Creates the section for creating axis-aligned planar Dirichlet BC.
+!> \param section the section to be created
+!> \param error cp2k error
+!>
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE create_aa_planar_section(section,error)
+    TYPE(section_type), POINTER              :: section
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'create_aa_planar_section', &
+      routineP = moduleN//':'//routineN
+
+    LOGICAL                                  :: failure
+    TYPE(keyword_type), POINTER              :: keyword
+
+    failure=.FALSE.
+
+    CPPrecondition(.NOT.ASSOCIATED(section), cp_failure_level, routineP, error, failure)
+    IF (.NOT. failure) THEN
+       CALL section_create(section,name="AA_PLANAR", &
+            description="Parameters for creating axis-aligned planar Dirichlet boundary region.",&
+            n_keywords=7, n_subsections=0, repeats=.TRUE., required=.FALSE.,&
+            error=error)
+
+       NULLIFY(keyword)
+
+       CALL keyword_create(keyword, name="v_D", variants = s2a('v', 'vg', 'v_g'), &
+            description="value of the potential at the Dirichlet boundary (e.g. gate voltage).", &
+!            usage="v_D 0.4", unit_str="volt", default_r_val=0.0E-1_dp, error=error)
+            usage="v_D <real>", default_r_val=1.0E-1_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="X_extents", variants = s2a('X', 'X_xtnt'), &
+            description="The X extents of the plane.", &
+            usage="X_extents <xmin(real)> <xmax(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="Y_extents", variants = s2a('Y', 'Y_xtnt'), &
+            description="The Y extents of the plane.", &
+            usage="Y_extents <ymin(real)> <ymax(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="Z_extents", variants = s2a('Z', 'Z_xtnt'), &
+            description="The Z extents of the plane.", &
+            usage="Z_extents <zmin(real)> <zmax(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="N_PARTITIONS", variants = s2a('N_PRTN'), &
+            description="The number of partitions in the x, y and z directions for tiling the plane.", &
+            usage="N_PARTITIONS <integer> <integer> <integer>", default_i_vals=(/1, 1, 1/), &
+            type_of_var=integer_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="SMOOTH", &
+            description="Whether or not to smoothen (mollify) the dirichlet boundary region to avoid "//&
+            "possible Gibbs phenomenon.", &
+            usage="SMOOTH <logical>", default_l_val=.FALSE., error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="smoothing_width", variants = s2a('zeta'),  &
+            description="The width of the standard mollifier.", &
+            usage="smoothing_width <real>", unit_str="angstrom", default_r_val=0.2_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+    END IF
+  END SUBROUTINE create_aa_planar_section
+
+! *****************************************************************************
+!> \brief Creates the section for creating axis-aligned planar Dirichlet BC.
+!> \param section the section to be created
+!> \param error cp2k error
+!>
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE create_planar_section(section,error)
+    TYPE(section_type), POINTER              :: section
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'create_planar_section', &
+      routineP = moduleN//':'//routineN
+
+    LOGICAL                                  :: failure
+    TYPE(keyword_type), POINTER              :: keyword
+
+    failure=.FALSE.
+
+    CPPrecondition(.NOT.ASSOCIATED(section), cp_failure_level, routineP, error, failure)
+    IF (.NOT. failure) THEN
+       CALL section_create(section,name="PLANAR", &
+            description="Parameters for creating an arbitrary planar Dirichlet boundary region.",&
+            n_keywords=8, n_subsections=0, repeats=.TRUE., required=.FALSE.,&
+            error=error)
+
+       NULLIFY(keyword)
+
+       CALL keyword_create(keyword, name="v_D", variants = s2a('v', 'vg', 'v_g'), &
+            description="value of the potential at the Dirichlet boundary (e.g. gate voltage).", &
+!            usage="v_D 0.4", unit_str="volt", default_r_val=0.0E-1_dp, error=error)
+            usage="v_D <real>", default_r_val=1.0E-1_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="A", variants = s2a('Avtx', 'A_vertex'), &
+            description="Coordinates of the vertex A.", &
+            usage="A <x(real)> <y(real)> <z(real)>", unit_str="angstrom", &
+            n_var=3, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="B", variants = s2a('Bvtx', 'B_vertex'), &
+            description="Coordinates of the vertex B.", &
+            usage="B <x(real)> <y(real)> <z(real)>", unit_str="angstrom", &
+            n_var=3, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="C", variants = s2a('Cvtx', 'C_vertex'), &
+            description="Coordinates of the vertex C.", &
+            usage="C <x(real)> <y(real)> <z(real)>", unit_str="angstrom", &
+            n_var=3, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="D", variants = s2a('Dvtx', 'D_vertex'), &
+            description="Coordinates of the vertex D.", &
+            usage="D <x(real)> <y(real)> <z(real)>", unit_str="angstrom", &
+            n_var=3, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="N_PARTITIONS", variants = s2a('N_PRTN'), &
+            description="The number of partitions in the x, y and z directions for tiling the plane.", &
+            usage="N_PARTITIONS <integer> <integer> <integer>", default_i_vals=(/1, 1, 1/), &
+            type_of_var=integer_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="SMOOTH", &
+            description="Whether or not to smoothen (mollify) the dirichlet boundary region to avoid "//&
+            "possible Gibbs phenomenon.", &
+            usage="SMOOTH <logical>", default_l_val=.FALSE., error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="smoothing_width", variants = s2a('zeta'),  &
+            description="The width of the standard mollifier.", &
+            usage="smoothing_width <real>", unit_str="angstrom", default_r_val=0.2_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+    END IF
+  END SUBROUTINE create_planar_section
+
+! *****************************************************************************
+!> \brief Creates the section for creating x-axis-aligned cylindrical Dirichlet BC.
+!> \param section the section to be created
+!> \param error cp2k error
+!>
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE create_xaa_cylindrical_section(section,error)
+    TYPE(section_type), POINTER              :: section
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(len=*), PARAMETER :: &
+      routineN = 'create_xaa_cylindrical_section', &
+      routineP = moduleN//':'//routineN
+
+    LOGICAL                                  :: failure
+    TYPE(keyword_type), POINTER              :: keyword
+
+    failure=.FALSE.
+
+    CPPrecondition(.NOT.ASSOCIATED(section), cp_failure_level, routineP, error, failure)
+    IF (.NOT. failure) THEN
+       CALL section_create(section,name="XAA_CYLINDRICAL", &
+            description="Parameters for creating x-axis-aligned cylindrical Dirichlet boundary region.",&
+            n_keywords=9, n_subsections=0, repeats=.TRUE., required=.FALSE.,&
+            error=error)
+
+       NULLIFY(keyword)
+
+       CALL keyword_create(keyword, name="v_D", variants = s2a('v', 'vg', 'v_g'), &
+            description="value of the potential at the Dirichlet boundary (e.g. gate voltage).", &
+!            usage="v_D 0.4", unit_str="volt", default_r_val=0.0E-1_dp, error=error)
+            usage="v_D <real>", default_r_val=1.0E-1_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="X_extents", variants = s2a('X', 'X_xtnt'), &
+            description="The X extents of the cylinder.", &
+            usage="X_extents <xmin(real)> <xmax(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="base_center", variants = s2a('center', 'O'), &
+            description="The y and z coordinates of the cylinder's base center.", &
+            usage="base_center <y(real)> <z(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="base_radius", variants = s2a('radius', 'r'), &
+            description="The base radius of the cylinder.", &
+            usage="base_radius <real>", default_r_val=1.0_dp, unit_str="angstrom", error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="n_sides", &
+            description="The number of sides os the n-gonal prism approximating the cylinder.", &
+            usage="n_sides <integer>", default_i_val=5, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="apx_type", &
+            variants = s2a('approximation_type', 'approximation_type'), &
+            enum_c_vals=s2a( 'CIRCUMSCRIBED', 'INSCRIBED' ), &
+            enum_i_vals=(/ CIRCUMSCRIBED, INSCRIBED /), &
+            description="Specifies the type of the n-gonal prism approximating the cylinder.", &
+            usage="apx_type <apx_type>", default_i_val=CIRCUMSCRIBED, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="N_PARTITIONS", variants = s2a('N_PRTN'), &
+            description="The number of partitions in the x, y and z directions for tiling the plane.", &
+            usage="N_PARTITIONS <integer> <integer> <integer>", default_i_vals=(/1, 1, 1/), &
+            type_of_var=integer_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="SMOOTH", &
+            description="Whether or not to smoothen (mollify) the dirichlet boundary region to avoid "//&
+            "possible Gibbs phenomenon.", &
+            usage="SMOOTH <logical>", default_l_val=.FALSE., error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="smoothing_width", variants = s2a('zeta'),  &
+            description="The width of the standard mollifier.", &
+            usage="smoothing_width <real>", unit_str="angstrom", default_r_val=0.2_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+    END IF
+  END SUBROUTINE create_xaa_cylindrical_section
+
+! *****************************************************************************
+!> \brief Creates the section for creating axis-aligned cuboidal Dirichlet region.
+!> \param section the section to be created
+!> \param error cp2k error
+!>
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE create_aa_cuboidal_section(section,error)
+    TYPE(section_type), POINTER              :: section
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'create_aa_cuboidal_section', &
+      routineP = moduleN//':'//routineN
+
+    LOGICAL                                  :: failure
+    TYPE(keyword_type), POINTER              :: keyword
+
+    failure=.FALSE.
+
+    CPPrecondition(.NOT.ASSOCIATED(section), cp_failure_level, routineP, error, failure)
+    IF (.NOT. failure) THEN
+       CALL section_create(section,name="AA_CUBOIDAL", &
+            description="Parameters for creating axis-aligned cuboidal region where a fixed voltage is applied.",&
+            n_keywords=7, n_subsections=0, repeats=.TRUE., required=.FALSE.,&
+            error=error)
+
+       NULLIFY(keyword)
+
+       CALL keyword_create(keyword, name="v_D", variants = s2a('v', 'vg', 'v_g'), &
+            description="value of the potential at the Dirichlet boundary (e.g. gate voltage).", &
+!            usage="v_D 0.4", unit_str="volt", default_r_val=0.0E-1_dp, error=error)
+            usage="v_D <real>", default_r_val=1.0E-1_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="X_extents", variants = s2a('X', 'X_xtnt'), &
+            description="The X extents of the cuboid.", &
+            usage="X_extents <xmin(real)> <xmax(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="Y_extents", variants = s2a('Y', 'Y_xtnt'), &
+            description="The Y extents of the cuboid.", &
+            usage="Y_extents <ymin(real)> <ymax(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="Z_extents", variants = s2a('Z', 'Z_xtnt'), &
+            description="The Z extents of the cuboid.", &
+            usage="Z_extents <zmin(real)> <zmax(real)>", unit_str="angstrom", &
+            n_var=2, type_of_var=real_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="N_PARTITIONS", variants = s2a('N_PRTN'), &
+            description="The number of partitions in the x, y and z directions for partitioning the cuboid.", &
+            usage="N_PARTITIONS <integer> <integer> <integer>", default_i_vals=(/1, 1, 1/), &
+            type_of_var=integer_t, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="SMOOTH", &
+            description="Whether or not to smoothen (mollify) the dirichlet region to avoid "//&
+            "possible Gibbs phenomenon.", &
+            usage="SMOOTH <logical>", default_l_val=.FALSE., error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+       CALL keyword_create(keyword, name="smoothing_width", variants = s2a('zeta'),  &
+            description="The width of the standard mollifier.", &
+            usage="smoothing_width <real>", unit_str="angstrom", default_r_val=0.2_dp, error=error)
+       CALL section_add_keyword(section, keyword, error=error)
+       CALL keyword_release(keyword, error=error)
+
+    END IF
+  END SUBROUTINE create_aa_cuboidal_section
+
 END MODULE input_cp2k_poisson
Index: pw/pw_poisson_methods.F
===================================================================
--- pw/pw_poisson_methods.F	(revision 14892)
+++ pw/pw_poisson_methods.F	(working copy)
@@ -9,12 +9,20 @@
 !> \author fawzi
 ! *****************************************************************************
 MODULE pw_poisson_methods
-  
+
+  USE dielectric_methods,              ONLY: dielectric_compute
   USE kinds,                           ONLY: dp
   USE mathconstants,                   ONLY: fourpi
   USE mt_util,                         ONLY: MT0D,&
                                              MT1D,&
                                              MT2D
+  USE ps_implicit_methods,             ONLY: implicit_poisson_solver_mixed,&
+                                             implicit_poisson_solver_mixed_periodic,&
+                                             implicit_poisson_solver_periodic,&
+                                             ps_implicit_create
+  USE ps_implicit_types,               ONLY: MIXED_BC,&
+                                             MIXED_PERIODIC_BC,&
+                                             PERIODIC_BC
   USE ps_wavelet_methods,              ONLY: cp2k_distribution_to_z_slices,&
                                              ps_wavelet_create,&
                                              ps_wavelet_solve,&
@@ -28,16 +36,18 @@
   USE pw_grids,                        ONLY: pw_grid_compare,&
                                              pw_grid_release,&
                                              pw_grid_retain
-  USE pw_methods,                      ONLY: pw_copy,&
+  USE pw_methods,                      ONLY: pw_axpy,&
+                                             pw_copy,&
                                              pw_derive,&
                                              pw_integral_ab,&
                                              pw_transfer
   USE pw_poisson_types,                ONLY: &
        ANALYTIC0D, ANALYTIC1D, ANALYTIC2D, MULTIPOLE0D, PERIODIC3D, &
-       do_ewald_spme, greens_fn_type, pw_green_create, pw_green_release, &
-       pw_poisson_analytic, pw_poisson_mt, pw_poisson_multipole, &
-       pw_poisson_none, pw_poisson_parameter_type, pw_poisson_periodic, &
-       pw_poisson_type, pw_poisson_wavelet
+       PS_IMPLICIT, do_ewald_spme, greens_fn_type, pw_green_create, &
+       pw_green_release, pw_poisson_analytic, pw_poisson_implicit, &
+       pw_poisson_mt, pw_poisson_multipole, pw_poisson_none, &
+       pw_poisson_parameter_type, pw_poisson_periodic, pw_poisson_type, &
+       pw_poisson_wavelet
   USE pw_pool_types,                   ONLY: pw_pool_create_pw,&
                                              pw_pool_give_back_pw,&
                                              pw_pool_p_type,&
@@ -192,33 +202,53 @@
     CHARACTER(len=*), PARAMETER :: routineN = 'pw_poisson_rebuild', &
       routineP = moduleN//':'//routineN
 
+    INTEGER                                  :: handle
     LOGICAL                                  :: failure
 
+    CALL timeset(routineN,handle)
+
     failure=.FALSE.
     CPPrecondition(ASSOCIATED(poisson_env),cp_failure_level,routineP,error,failure)
     CPPrecondition(poisson_env%ref_count>0,cp_failure_level,routineP,error,failure)
     CPPrecondition(ASSOCIATED(poisson_env%pw_pools),cp_failure_level,routineP,error,failure)
+
     IF (.NOT. failure) THEN
        IF (poisson_env%rebuild) THEN
-          CALL pw_poisson_cleanup(poisson_env,error=error)
+           CALL pw_poisson_cleanup(poisson_env,error=error)
            SELECT CASE (poisson_env%parameters%solver)
-           CASE(pw_poisson_periodic,pw_poisson_analytic,pw_poisson_mt,pw_poisson_multipole)
+           CASE (pw_poisson_periodic, pw_poisson_analytic, pw_poisson_mt, pw_poisson_multipole)
               CALL pw_green_create(poisson_env%green_fft,cell_hmat=poisson_env%cell_hmat,&
-                   pw_pool=poisson_env%pw_pools(poisson_env%pw_level)%pool,&
-                   poisson_params=poisson_env%parameters,&
-                   mt_super_ref_pw_grid=poisson_env%mt_super_ref_pw_grid,&
-                   error=error)
-           CASE(pw_poisson_wavelet)
+                      pw_pool=poisson_env%pw_pools(poisson_env%pw_level)%pool,&
+                      poisson_params=poisson_env%parameters,&
+                      mt_super_ref_pw_grid=poisson_env%mt_super_ref_pw_grid,&
+                      dct_pw_grid=poisson_env%dct_aux_pw_grid,&
+                      error=error)
+           CASE (pw_poisson_wavelet)
               CPPrecondition(ASSOCIATED(density%pw_grid),cp_failure_level,routineP,error,failure)
               CALL ps_wavelet_create(poisson_env%parameters,poisson_env%wavelet,&
                                      density%pw_grid,error)
-           CASE(pw_poisson_none)
+           CASE (pw_poisson_implicit)
+              CALL pw_green_create(poisson_env%green_fft,cell_hmat=poisson_env%cell_hmat,&
+                      pw_pool=poisson_env%pw_pools(poisson_env%pw_level)%pool,&
+                      poisson_params=poisson_env%parameters,&
+                      mt_super_ref_pw_grid=poisson_env%mt_super_ref_pw_grid,&
+                      dct_pw_grid=poisson_env%dct_aux_pw_grid,&
+                      error=error)
+              CALL ps_implicit_create(poisson_env%pw_pools(poisson_env%pw_level)%pool, &
+                      poisson_env%parameters, &
+                      poisson_env%dct_pw_grid, &
+                      poisson_env%dct_aux_pw_grid, &
+                      poisson_env%green_fft, poisson_env%implicit_env, error)
+           CASE (pw_poisson_none)
            CASE default
               CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
            END SELECT
           poisson_env%rebuild=.FALSE.
        END IF
     END IF
+
+    CALL timestop(handle)
+
   END SUBROUTINE pw_poisson_rebuild
 
 ! *****************************************************************************
@@ -231,13 +261,14 @@
 !> \param vhartree ...
 !> \param dvhartree ...
 !> \param h_stress ...
+!> \param rho_core ...
 !> \param error ...
 !> \par History
 !>      JGH (13-Mar-2001) : completely revised
 !> \author apsi
 ! *****************************************************************************
   SUBROUTINE pw_poisson_solve ( poisson_env, density, ehartree, vhartree,&
-       dvhartree, h_stress, error )
+       dvhartree, h_stress, rho_core, error )
 
     TYPE(pw_poisson_type), POINTER           :: poisson_env
     TYPE(pw_type), POINTER                   :: density
@@ -246,6 +277,7 @@
     TYPE(pw_p_type), DIMENSION(3), OPTIONAL  :: dvhartree
     REAL(KIND=dp), DIMENSION(3, 3), &
       INTENT(OUT), OPTIONAL                  :: h_stress
+    TYPE(pw_p_type), OPTIONAL, POINTER       :: rho_core
     TYPE(cp_error_type), INTENT(inout)       :: error
 
     CHARACTER(len=*), PARAMETER :: routineN = 'pw_poisson_solve', &
@@ -253,12 +285,14 @@
 
     INTEGER                                  :: alpha, beta, handle, i, ig, ng
     INTEGER, DIMENSION(3)                    :: n
-    LOGICAL                                  :: failure
+    LOGICAL                                  :: failure, has_dielectric
     REAL(KIND=dp)                            :: ffa
     TYPE(pw_grid_type), POINTER              :: pw_grid
     TYPE(pw_p_type)                          :: dvg( 3 )
+    TYPE(pw_poisson_parameter_type), POINTER :: poisson_params
     TYPE(pw_pool_type), POINTER              :: pw_pool
-    TYPE(pw_type), POINTER                   :: rhog, rhor, tmpg
+    TYPE(pw_type), POINTER                   :: rhog, rhor, tmpg, v_eps, &
+                                                vhartree_rs
 
     CALL timeset(routineN,handle)
 
@@ -269,7 +303,12 @@
        CALL pw_poisson_rebuild(poisson_env,density,error=error)
        CALL cp_error_check(error,failure)
     END IF
+    poisson_params => poisson_env%parameters
+
     IF (.NOT.failure) THEN
+
+       has_dielectric = poisson_params%has_dielectric
+
        NULLIFY (pw_grid,rhog)
        ! point pw
        pw_pool => poisson_env%pw_pools(poisson_env%pw_level)%pool
@@ -281,14 +320,17 @@
                "vhartree has a different grid than the poisson solver",error,failure)
        END IF
        ! density in G space
-       CALL pw_pool_create_pw ( pw_pool,rhog, use_data=COMPLEXDATA1D,in_space = RECIPROCALSPACE,&
+       CALL pw_pool_create_pw ( pw_pool, rhog, use_data=COMPLEXDATA1D,in_space = RECIPROCALSPACE,&
             error=error)
        ! apply the greens function
        ng = SIZE ( pw_grid % gsq )
+
        SELECT CASE (poisson_env%used_grid)
        CASE (use_gs_grid)
+
           SELECT CASE (poisson_env%green_fft%method)
           CASE (PERIODIC3D,ANALYTIC2D,ANALYTIC1D,ANALYTIC0D,MT2D,MT1D,MT0D,MULTIPOLE0D)
+
              CALL pw_transfer(density,rhog,error=error)
              IF (PRESENT(ehartree).AND.(.NOT.PRESENT(vhartree))) THEN
                 CALL pw_pool_create_pw(pw_pool,tmpg,use_data=COMPLEXDATA1D,&
@@ -307,11 +349,52 @@
                 ehartree = 0.5_dp*pw_integral_ab(rhog,tmpg,error=error)
                 CALL pw_pool_give_back_pw(pw_pool,tmpg,error=error)
              END IF
+
+          CASE (PS_IMPLICIT)
+
+             IF (has_dielectric .AND. PRESENT(rho_core)) THEN
+                CALL dielectric_compute(poisson_env%implicit_env%dielectric, &
+                                       poisson_env%diel_rs_grid,&
+                                       poisson_env%pw_pools(poisson_env%pw_level)%pool, &
+                                       density, rho_core=rho_core%pw, error=error)
+             END IF
+
+             CALL pw_pool_create_pw(pw_pool, rhor, use_data=REALDATA3D, in_space=REALSPACE, error=error)
+             CALL pw_pool_create_pw(pw_pool, vhartree_rs, use_data=REALDATA3D, in_space=REALSPACE, error=error)
+             CALL pw_transfer(density, rhor, error=error)
+
+             SELECT CASE (poisson_params%ps_implicit_params%boundary_condition)
+                CASE (PERIODIC_BC)
+                   CALL implicit_poisson_solver_periodic(poisson_env, rhor, vhartree_rs, &
+                                                      v_eps, ehartree=ehartree, error=error)
+                CASE (MIXED_PERIODIC_BC)
+                   CALL implicit_poisson_solver_mixed_periodic(poisson_env, rhor, vhartree_rs, &
+                                                      v_eps, ehartree=ehartree, error=error)
+                CASE (MIXED_BC)
+                   CALL implicit_poisson_solver_mixed(poisson_env, rhor, vhartree_rs, &
+                                                      v_eps, ehartree=ehartree, error=error)
+             END SELECT
+
+             IF (PRESENT(vhartree)) THEN
+                CALL pw_axpy(v_eps, vhartree_rs, - 1.0_dp, error=error)
+                CALL pw_transfer(vhartree_rs, vhartree, error=error)
+                CALL pw_pool_give_back_pw(pw_pool, v_eps, error=error)
+             END IF
+
+             IF (PRESENT(h_stress).OR.PRESENT(dvhartree)) THEN
+                CALL pw_transfer(rhor,rhog,error=error)
+             END IF
+
+             CALL pw_pool_give_back_pw(pw_pool, rhor, error=error)
+             CALL pw_pool_give_back_pw(pw_pool, vhartree_rs, error=error)
+
           CASE DEFAULT
              CALL cp_unimplemented_error(routineP,"unknown poisson method "//&
                                          cp_to_string(poisson_env%green_fft%method),error)
           END SELECT
+
        CASE (use_rs_grid)
+
           IF (PRESENT(vhartree)) THEN
              CPPrecondition(ASSOCIATED(vhartree),cp_failure_level,routineP,error,failure)
              CALL cp_assert(pw_grid_compare(pw_pool%pw_grid,vhartree%pw_grid),cp_assertion_failed,&
@@ -335,6 +418,7 @@
              CALL pw_transfer(rhor,rhog,error=error)
           END IF
           CALL pw_pool_give_back_pw(pw_pool,rhor,error=error)
+
        END SELECT
 
        ! do we need to calculate the derivative of the potential?
@@ -367,12 +451,14 @@
                    h_stress ( beta, alpha ) = h_stress ( alpha, beta )
                 END DO
              END DO
+
              ! Handle the periodicity cases for the Stress Tensor
              SELECT CASE(poisson_env%used_grid)
              CASE(use_gs_grid)
+
                 ! FFT based Poisson-Solver
                 SELECT CASE(poisson_env%green_fft%method)
-                CASE(PERIODIC3D)
+                CASE(PERIODIC3D, PS_IMPLICIT)
                    ! Do Nothing
                 CASE(ANALYTIC2D, MT2D)
                    ! Zero the 1 non-periodic component
@@ -399,7 +485,9 @@
                    CALL cp_unimplemented_error(routineP,"unknown poisson method"//&
                         cp_to_string(poisson_env%green_fft%method),error)
                 END SELECT
+
              CASE(use_rs_grid)
+
                 ! Wavelet based Poisson-Solver
                 SELECT CASE(poisson_env%wavelet%method)
                 CASE(WAVELET3D)
@@ -417,13 +505,15 @@
                    ! Zero the full stress tensor
                    h_stress = 0.0_dp
                 END SELECT
+
              END SELECT
           END IF
+
           DO i = 1, 3
              CALL pw_pool_give_back_pw ( pw_pool, dvg ( i )%pw, error=error )
           END DO
+
        END IF
-
        CALL pw_pool_give_back_pw (pw_pool, rhog, error=error )
     ELSE
        ! stop on failure ?!
@@ -446,6 +536,8 @@
 !> \param pw_pools ...
 !> \param use_level ...
 !> \param mt_super_ref_pw_grid ...
+!> \param dct_pw_grid ...
+!> \param dct_aux_pw_grid ...
 !> \param force_rebuild ...
 !> \param error ...
 !> \author fawzi
@@ -454,8 +546,8 @@
 !>      this method the poisson env must be fully ready, so the first time
 !>      you have to set everything at once. Change this behaviour?
 ! *****************************************************************************
-  SUBROUTINE pw_poisson_set ( poisson_env, cell_hmat, parameters, pw_pools,&
-       use_level, mt_super_ref_pw_grid, force_rebuild, error )
+  SUBROUTINE pw_poisson_set ( poisson_env, cell_hmat, parameters, pw_pools, use_level, &
+              mt_super_ref_pw_grid, dct_pw_grid, dct_aux_pw_grid, force_rebuild, error )
 
     TYPE(pw_poisson_type), POINTER           :: poisson_env
     REAL(KIND=dp), DIMENSION(3, 3), &
@@ -465,18 +557,21 @@
     TYPE(pw_pool_p_type), DIMENSION(:), &
       OPTIONAL, POINTER                      :: pw_pools
     INTEGER, INTENT(in), OPTIONAL            :: use_level
-    TYPE(pw_grid_type), OPTIONAL, POINTER    :: mt_super_ref_pw_grid
+    TYPE(pw_grid_type), OPTIONAL, POINTER    :: mt_super_ref_pw_grid, &
+                                                dct_pw_grid, dct_aux_pw_grid
     LOGICAL, INTENT(in), OPTIONAL            :: force_rebuild
     TYPE(cp_error_type), INTENT(inout)       :: error
 
     CHARACTER(len=*), PARAMETER :: routineN = 'pw_poisson_set', &
       routineP = moduleN//':'//routineN
 
-    INTEGER                                  :: i
+    INTEGER                                  :: handle, i
     LOGICAL                                  :: failure, same
     TYPE(pw_pool_p_type), DIMENSION(:), &
       POINTER                                :: tmp_pools
 
+    CALL timeset(routineN,handle)
+
     IF (PRESENT(parameters)) &
        poisson_env%parameters = parameters
 
@@ -486,6 +581,7 @@
        poisson_env%cell_hmat(:,:) = cell_hmat(:,:)
        poisson_env%rebuild=.TRUE.
     END IF
+
     IF (PRESENT(pw_pools)) THEN
        CPPrecondition(ASSOCIATED(pw_pools),cp_failure_level,routineP,error,failure)
        same=.FALSE.
@@ -505,7 +601,25 @@
           poisson_env%pw_pools => tmp_pools
        END IF
     END IF
+
     IF (PRESENT(use_level)) poisson_env%pw_level=use_level
+
+    IF (PRESENT(dct_pw_grid)) THEN
+       IF (ASSOCIATED(dct_pw_grid)) THEN
+          CALL pw_grid_retain(dct_pw_grid,error=error)
+       END IF
+       CALL pw_grid_release(poisson_env%dct_pw_grid,error=error)
+       poisson_env%dct_pw_grid => dct_pw_grid
+    END IF
+
+    IF (PRESENT(dct_aux_pw_grid)) THEN
+       IF (ASSOCIATED(dct_aux_pw_grid)) THEN
+          CALL pw_grid_retain(dct_aux_pw_grid,error=error)
+       END IF
+       CALL pw_grid_release(poisson_env%dct_aux_pw_grid,error=error)
+       poisson_env%dct_aux_pw_grid => dct_aux_pw_grid
+    END IF
+
     IF (PRESENT(mt_super_ref_pw_grid)) THEN
        IF (ASSOCIATED(mt_super_ref_pw_grid)) THEN
           CALL pw_grid_retain(mt_super_ref_pw_grid,error=error)
@@ -513,10 +627,15 @@
        CALL pw_grid_release(poisson_env%mt_super_ref_pw_grid,error=error)
        poisson_env%mt_super_ref_pw_grid => mt_super_ref_pw_grid
     END IF
+
     IF (PRESENT(force_rebuild)) THEN
        IF (force_rebuild) poisson_env%rebuild=.TRUE.
     END IF
+
     CALL pw_poisson_check(poisson_env,error=error)
+
+    CALL timestop(handle)
+
   END SUBROUTINE pw_poisson_set
 
 END MODULE pw_poisson_methods
Index: pw/pw_methods.F
===================================================================
--- pw/pw_methods.F	(revision 14892)
+++ pw/pw_methods.F	(working copy)
@@ -1502,6 +1502,7 @@
        IF ( test .AND. pw1%pw_grid%para%group_head ) THEN
           WRITE ( *,'(A)') " FFT Protocol "
           IF ( dir == FWFFT ) WRITE ( *,'(A,T76,A)') "  Transform direction ","FWFFT"
+          IF ( dir == BWFFT ) WRITE ( *,'(A,T76,A)') "  Transform direction ","BWFFT"
           IF ( pw1%in_space == REALSPACE ) &
                WRITE ( *,'(A,T72,A)') "  in space ","REALSPACE"
           IF ( pw1%in_space == RECIPROCALSPACE ) &
Index: pw/pw_grids.F
===================================================================
--- pw/pw_grids.F	(revision 14892)
+++ pw/pw_grids.F	(working copy)
@@ -40,9 +40,9 @@
   USE mathlib,                         ONLY: det_3x3,&
                                              inv_3x3
   USE message_passing,                 ONLY: &
-       MPI_COMM_SELF, mp_cart_coords, mp_cart_create, mp_cart_rank, &
-       mp_comm_compare, mp_comm_dup, mp_comm_free, mp_dims_create, &
-       mp_environ, mp_max, mp_min, mp_sum
+       MPI_COMM_SELF, mp_allgather, mp_cart_coords, mp_cart_create, &
+       mp_cart_rank, mp_comm_compare, mp_comm_dup, mp_comm_free, &
+       mp_dims_create, mp_environ, mp_max, mp_min, mp_sum
   USE pw_grid_info,                    ONLY: pw_find_cutoff,&
                                              pw_grid_bounds_from_n,&
                                              pw_grid_init_setup
@@ -334,6 +334,7 @@
 !> \param grid_span ...
 !> \param cutoff ...
 !> \param bounds ...
+!> \param bounds_local ...
 !> \param npts ...
 !> \param spherical ...
 !> \param odd ...
@@ -350,7 +351,7 @@
 !> \note
 !>      this is the function that should be used in the future
 ! *****************************************************************************
-  SUBROUTINE pw_grid_setup (cell_hmat, pw_grid, grid_span, cutoff, bounds, npts, &
+  SUBROUTINE pw_grid_setup (cell_hmat, pw_grid, grid_span, cutoff, bounds, bounds_local, npts, &
        spherical, odd, fft_usage, ncommensurate, icommensurate, blocked, ref_grid,&
        rs_dims, iounit, error )
 
@@ -360,7 +361,7 @@
     INTEGER, INTENT(in), OPTIONAL            :: grid_span
     REAL(KIND=dp), INTENT(IN), OPTIONAL      :: cutoff
     INTEGER, DIMENSION(2, 3), INTENT(IN), &
-      OPTIONAL                               :: bounds
+      OPTIONAL                               :: bounds, bounds_local
     INTEGER, DIMENSION(3), INTENT(IN), &
       OPTIONAL                               :: npts
     LOGICAL, INTENT(in), OPTIONAL            :: spherical, odd, fft_usage
@@ -467,7 +468,8 @@
                          "BOUNDS, NPTS or CUTOFF have to be specified")
     END IF
 
-    CALL pw_grid_setup_internal (cell_hmat, cell_h_inv, cell_deth, pw_grid, blocked, ref_grid, rs_dims, iounit, error )
+    CALL pw_grid_setup_internal (cell_hmat, cell_h_inv, cell_deth, pw_grid, bounds_local=bounds_local, &
+                                 blocked=blocked, ref_grid=ref_grid, rs_dims=rs_dims, iounit=iounit, error=error )
 
 #if defined ( __PW_CUDA )
     CALL pw_grid_create_ghatmap ( pw_grid, error )
@@ -576,6 +578,7 @@
 !> \param cell_h_inv ...
 !> \param cell_deth ...
 !> \param pw_grid ...
+!> \param bounds_local ...
 !> \param blocked ...
 !> \param ref_grid ...
 !> \param rs_dims ...
@@ -596,11 +599,14 @@
 !> \note
 !>      this is the function that should be used in the future
 ! *****************************************************************************
-  SUBROUTINE pw_grid_setup_internal (cell_hmat, cell_h_inv, cell_deth, pw_grid, blocked, ref_grid, rs_dims, iounit, error )
+  SUBROUTINE pw_grid_setup_internal (cell_hmat, cell_h_inv, cell_deth, pw_grid, bounds_local, &
+                                     blocked, ref_grid, rs_dims, iounit, error )
     REAL(KIND=dp), DIMENSION(3, 3), &
       INTENT(IN)                             :: cell_hmat, cell_h_inv
     REAL(KIND=dp), INTENT(IN)                :: cell_deth
     TYPE(pw_grid_type), POINTER              :: pw_grid
+    INTEGER, DIMENSION(2, 3), INTENT(IN), &
+      OPTIONAL                               :: bounds_local
     INTEGER, INTENT(in), OPTIONAL            :: blocked
     TYPE(pw_grid_type), INTENT(in), OPTIONAL :: ref_grid
     INTEGER, DIMENSION(2), INTENT(in), &
@@ -611,13 +617,15 @@
     CHARACTER(len=*), PARAMETER :: routineN = 'pw_grid_setup_internal', &
       routineP = moduleN//':'//routineN
 
-    INTEGER                                  :: allocstat, ires, n(3)
+    INTEGER                                  :: allocstat, handle, ires, n(3)
     INTEGER, ALLOCATABLE, DIMENSION(:, :)    :: yz_mask
     LOGICAL                                  :: failure
     REAL(KIND=dp)                            :: ecut
 
 !------------------------------------------------------------------------------
 
+    CALL timeset(routineN,handle)
+
     failure=.FALSE.
     CPPrecondition(ASSOCIATED(pw_grid),cp_failure_level,routineP,error,failure)
     CPPrecondition(pw_grid%ref_count>0,cp_failure_level,routineP,error,failure)
@@ -656,7 +664,7 @@
     END IF
 
     ! Distribute grid
-    CALL pw_grid_distribute ( pw_grid, yz_mask, ref_grid, blocked, &
+    CALL pw_grid_distribute ( pw_grid, yz_mask, bounds_local=bounds_local, ref_grid=ref_grid, blocked=blocked, &
          rs_dims=rs_dims ,error=error)
 
     ! Allocate the grid fields
@@ -683,6 +691,8 @@
        CALL pw_grid_print ( pw_grid, iounit, error )
     END IF
 
+    CALL timestop(handle)
+
   END SUBROUTINE pw_grid_setup_internal
 
 ! *****************************************************************************
@@ -845,6 +855,7 @@
 !> \brief Distribute grids in real and Fourier Space to the processors in group
 !> \param pw_grid ...
 !> \param yz_mask ...
+!> \param bounds_local ...
 !> \param ref_grid ...
 !> \param blocked ...
 !> \param rs_dims ...
@@ -855,10 +866,12 @@
 !>      JGH (09-Sep-2003) reduce scaling for distribution
 !> \author JGH (22-12-2000)
 ! *****************************************************************************
-  SUBROUTINE pw_grid_distribute ( pw_grid, yz_mask, ref_grid, blocked, rs_dims, error)
+  SUBROUTINE pw_grid_distribute ( pw_grid, yz_mask, bounds_local, ref_grid, blocked, rs_dims, error)
 
     TYPE(pw_grid_type), POINTER              :: pw_grid
     INTEGER, DIMENSION(:, :), INTENT(INOUT)  :: yz_mask
+    INTEGER, DIMENSION(2, 3), INTENT(IN), &
+      OPTIONAL                               :: bounds_local
     TYPE(pw_grid_type), INTENT(IN), OPTIONAL :: ref_grid
     INTEGER, INTENT(IN), OPTIONAL            :: blocked
     INTEGER, DIMENSION(2), INTENT(in), &
@@ -873,6 +886,8 @@
       rsd( 2 )
     INTEGER, ALLOCATABLE, DIMENSION(:)       :: pemap
     INTEGER, ALLOCATABLE, DIMENSION(:, :)    :: yz_index
+    INTEGER, ALLOCATABLE, DIMENSION(:, :, :) :: axis_dist_all
+    INTEGER, DIMENSION(2, 3)                 :: axis_dist
     LOGICAL                                  :: blocking, failure
 
 !------------------------------------------------------------------------------
@@ -1003,13 +1018,19 @@
        CALL mp_cart_rank ( pw_grid % para % rs_group, &
             pw_grid % para % rs_pos, &
             pw_grid % para % rs_mpo )
-       lo = get_limit ( nx, pw_grid % para % rs_dims ( 1 ), &
-            pw_grid % para % rs_pos ( 1 ) )
-       pw_grid % bounds_local ( :, 1 ) = lo + pw_grid % bounds ( 1, 1 ) - 1
-       lo = get_limit ( ny, pw_grid % para % rs_dims ( 2 ), &
-            pw_grid % para % rs_pos ( 2 ) )
-       pw_grid % bounds_local ( :, 2 ) = lo + pw_grid % bounds ( 1, 2 ) - 1
-       pw_grid % bounds_local ( :, 3 ) = pw_grid % bounds ( :, 3 )
+
+       IF (PRESENT(bounds_local)) THEN
+          pw_grid % bounds_local = bounds_local
+       ELSE
+          lo = get_limit ( nx, pw_grid % para % rs_dims ( 1 ), &
+               pw_grid % para % rs_pos ( 1 ) )
+          pw_grid % bounds_local ( :, 1 ) = lo + pw_grid % bounds ( 1, 1 ) - 1
+          lo = get_limit ( ny, pw_grid % para % rs_dims ( 2 ), &
+               pw_grid % para % rs_pos ( 2 ) )
+          pw_grid % bounds_local ( :, 2 ) = lo + pw_grid % bounds ( 1, 2 ) - 1
+          pw_grid % bounds_local ( :, 3 ) = pw_grid % bounds ( :, 3 )
+       END IF
+
        pw_grid % npts_local ( : ) = pw_grid % bounds_local ( 2, : ) &
             - pw_grid % bounds_local ( 1, : ) + 1
 
@@ -1017,25 +1038,53 @@
        ALLOCATE ( pw_grid % para % bo ( 2, 3, 0:np-1, 3 ), STAT = ierr )
        CPPrecondition(ierr == 0,cp_failure_level,routineP,error,failure)
        rsd = pw_grid % para % rs_dims
-       DO ip = 0, np - 1
-          CALL mp_cart_coords ( pw_grid % para % rs_group, ip, coor )
-          ! distribution xyZ
-          pw_grid % para % bo ( 1:2, 1, ip, 1 ) = get_limit (nx,rsd(1),coor(1))
-          pw_grid % para % bo ( 1:2, 2, ip, 1 ) = get_limit (ny,rsd(2),coor(2))
-          pw_grid % para % bo ( 1, 3, ip, 1 ) = 1
-          pw_grid % para % bo ( 2, 3, ip, 1 ) = nz
-          ! distribution xYz
-          pw_grid % para % bo ( 1:2, 1, ip, 2 ) = get_limit (nx,rsd(1),coor(1))
-          pw_grid % para % bo ( 1, 2, ip, 2 ) = 1
-          pw_grid % para % bo ( 2, 2, ip, 2 ) = ny
-          pw_grid % para % bo ( 1:2, 3, ip, 2 ) = get_limit (nz,rsd(2),coor(2))
-          ! distribution Xyz
-          pw_grid % para % bo ( 1, 1, ip, 3 ) = 1
-          pw_grid % para % bo ( 2, 1, ip, 3 ) = nx
-          pw_grid % para % bo ( 1:2, 2, ip, 3 ) = get_limit (ny,rsd(1),coor(1))
-          pw_grid % para % bo ( 1:2, 3, ip, 3 ) = get_limit (nz,rsd(2),coor(2))
-       END DO
 
+       IF (PRESENT(bounds_local)) THEN
+       !> axis_dist tells what portion of 1 .. nx , 1 .. ny , 1 .. nz are in the current process
+          DO i = 1, 3
+             axis_dist(:,i) = bounds_local(:,i) - pw_grid%bounds(1,i) + 1
+          END DO
+          ALLOCATE(axis_dist_all(2,3,np))
+          CALL mp_allgather(axis_dist, axis_dist_all, pw_grid%para%rs_group)
+          DO ip = 0, np - 1
+             CALL mp_cart_coords ( pw_grid % para % rs_group, ip, coor )
+             ! distribution xyZ
+             pw_grid % para % bo ( 1:2, 1, ip, 1 ) = axis_dist_all(1:2,1,ip+1)
+             pw_grid % para % bo ( 1:2, 2, ip, 1 ) = axis_dist_all(1:2,2,ip+1)
+             pw_grid % para % bo ( 1, 3, ip, 1 ) = 1
+             pw_grid % para % bo ( 2, 3, ip, 1 ) = nz
+             ! distribution xYz
+             pw_grid % para % bo ( 1:2, 1, ip, 2 ) = axis_dist_all(1:2,1,ip+1)
+             pw_grid % para % bo ( 1, 2, ip, 2 ) = 1
+             pw_grid % para % bo ( 2, 2, ip, 2 ) = ny
+             pw_grid % para % bo ( 1:2, 3, ip, 2 ) = axis_dist_all(1:2,3,ip+1)
+             ! distribution Xyz
+             pw_grid % para % bo ( 1, 1, ip, 3 ) = 1
+             pw_grid % para % bo ( 2, 1, ip, 3 ) = nx
+             pw_grid % para % bo ( 1:2, 2, ip, 3 ) = axis_dist_all(1:2,2,ip+1)
+             pw_grid % para % bo ( 1:2, 3, ip, 3 ) = axis_dist_all(1:2,3,ip+1)
+          END DO
+          DEALLOCATE(axis_dist_all)
+       ELSE
+          DO ip = 0, np - 1
+             CALL mp_cart_coords ( pw_grid % para % rs_group, ip, coor )
+             ! distribution xyZ
+             pw_grid % para % bo ( 1:2, 1, ip, 1 ) = get_limit (nx,rsd(1),coor(1))
+             pw_grid % para % bo ( 1:2, 2, ip, 1 ) = get_limit (ny,rsd(2),coor(2))
+             pw_grid % para % bo ( 1, 3, ip, 1 ) = 1
+             pw_grid % para % bo ( 2, 3, ip, 1 ) = nz
+             ! distribution xYz
+             pw_grid % para % bo ( 1:2, 1, ip, 2 ) = get_limit (nx,rsd(1),coor(1))
+             pw_grid % para % bo ( 1, 2, ip, 2 ) = 1
+             pw_grid % para % bo ( 2, 2, ip, 2 ) = ny
+             pw_grid % para % bo ( 1:2, 3, ip, 2 ) = get_limit (nz,rsd(2),coor(2))
+             ! distribution Xyz
+             pw_grid % para % bo ( 1, 1, ip, 3 ) = 1
+             pw_grid % para % bo ( 2, 1, ip, 3 ) = nx
+             pw_grid % para % bo ( 1:2, 2, ip, 3 ) = get_limit (ny,rsd(1),coor(1))
+             pw_grid % para % bo ( 1:2, 3, ip, 3 ) = get_limit (nz,rsd(2),coor(2))
+          END DO
+       END IF
        !..find the g space distribution
        pw_grid % ngpts_cut_local = 0
 
@@ -1085,6 +1134,7 @@
                 yz_mask ( m, n ) = 0
              END IF
           END DO
+
           DEALLOCATE ( yz_index, STAT = ierr )
           CPPrecondition(ierr == 0,cp_failure_level,routineP,error,failure)
 
Index: pw/pw_poisson_types.F
===================================================================
--- pw/pw_poisson_types.F	(revision 14892)
+++ pw/pw_poisson_types.F	(working copy)
@@ -22,6 +22,8 @@
                                              bessj1,&
                                              bessk0,&
                                              bessk1
+  USE dielectric_types,                ONLY: dielectric_parameters
+  USE dirichlet_bc_types,              ONLY: dirichlet_bc_parameters
   USE kinds,                           ONLY: dp
   USE mathconstants,                   ONLY: fourpi,&
                                              twopi
@@ -29,13 +31,19 @@
                                              MT1D,&
                                              MT2D,&
                                              MTin_create_screen_fn
+  USE ps_implicit_types,               ONLY: MIXED_BC,&
+                                             ps_implicit_parameters,&
+                                             ps_implicit_release,&
+                                             ps_implicit_type
   USE ps_wavelet_types,                ONLY: ps_wavelet_release,&
                                              ps_wavelet_type
   USE pw_grid_types,                   ONLY: pw_grid_type
   USE pw_grids,                        ONLY: pw_grid_release
-  USE pw_pool_types,                   ONLY: pw_pool_create_pw,&
+  USE pw_pool_types,                   ONLY: pw_pool_create,&
+                                             pw_pool_create_pw,&
                                              pw_pool_give_back_pw,&
                                              pw_pool_p_type,&
+                                             pw_pool_release,&
                                              pw_pool_type,&
                                              pw_pools_dealloc
   USE pw_types,                        ONLY: COMPLEXDATA1D,&
@@ -43,6 +51,8 @@
                                              RECIPROCALSPACE,&
                                              pw_release,&
                                              pw_type
+  USE realspace_grid_types,            ONLY: realspace_grid_type,&
+                                             rs_grid_release
 #include "../common/cp_common_uses.f90"
 
   IMPLICIT NONE
@@ -67,7 +77,8 @@
                                               pw_poisson_mt=3,&
                                               pw_poisson_hockney=5,&
                                               pw_poisson_multipole=4,&
-                                              pw_poisson_wavelet=6
+                                              pw_poisson_wavelet=6,&
+                                              pw_poisson_implicit=7
   ! EWALD methods
   INTEGER, PARAMETER, PUBLIC               :: do_ewald_none=1,&
                                               do_ewald_ewald=2,&
@@ -83,27 +94,35 @@
                                               HOCKNEY0D = 1203,&
                                               MULTIPOLE2D = 1301,&
                                               MULTIPOLE1D = 1302,&
-                                              MULTIPOLE0D = 1303
+                                              MULTIPOLE0D = 1303,&
+                                              PS_IMPLICIT = 1400
 
 ! *****************************************************************************
 !> \brief parameters for the poisson solver independet of input_section
 !> \author Ole Schuett
 ! *****************************************************************************
   TYPE pw_poisson_parameter_type
-    INTEGER                                  :: solver
-    INTEGER, DIMENSION(3)                    :: periodic
-    INTEGER                                  :: ewald_type = do_ewald_none
-    INTEGER                                  :: ewald_o_spline
-    REAL (KIND=dp)                           :: ewald_alpha
-    REAL (KIND=dp)                           :: mt_rel_cutoff
-    REAL (KIND=dp)                           :: mt_alpha
-    INTEGER                                  :: wavelet_scf_type
-    INTEGER                                  :: wavelet_method
-    INTEGER                                  :: wavelet_special_dimension
-    CHARACTER(LEN=1)                         :: wavelet_geocode
+    INTEGER                        :: solver
+
+    INTEGER, DIMENSION(3)          :: periodic
+    INTEGER                        :: ewald_type = do_ewald_none
+    INTEGER                        :: ewald_o_spline
+    REAL (KIND=dp)                 :: ewald_alpha
+
+    REAL (KIND=dp)                 :: mt_rel_cutoff
+    REAL (KIND=dp)                 :: mt_alpha
+
+    INTEGER                        :: wavelet_scf_type
+    INTEGER                        :: wavelet_method
+    INTEGER                        :: wavelet_special_dimension
+    CHARACTER(LEN=1)               :: wavelet_geocode
+
+    LOGICAL                        :: has_dielectric
+    TYPE(dielectric_parameters)    :: dielectric_params
+    TYPE(ps_implicit_parameters)   :: ps_implicit_params
+    TYPE(dirichlet_bc_parameters)  :: dbc_params
   END TYPE pw_poisson_parameter_type
 
-
 ! *****************************************************************************
 !> \brief environment for the poisson solver
 !> \author fawzi
@@ -114,12 +133,16 @@
      INTEGER :: method
      INTEGER :: used_grid
      LOGICAL :: rebuild
-     TYPE ( greens_fn_type ), POINTER :: green_fft
-     TYPE (ps_wavelet_type ),POINTER  :: wavelet
-     TYPE (pw_poisson_parameter_type) :: parameters
-     REAL(KIND = dp), DIMENSION(3,3)   :: cell_hmat = 0.0_dp
-     TYPE(pw_pool_p_type), DIMENSION(:), POINTER :: pw_pools
-     TYPE ( pw_grid_type), POINTER :: mt_super_ref_pw_grid
+     TYPE (greens_fn_type), POINTER               :: green_fft
+     TYPE (ps_wavelet_type),POINTER               :: wavelet
+     TYPE (pw_poisson_parameter_type)             :: parameters
+     REAL (KIND = dp), DIMENSION(3,3)             :: cell_hmat = 0.0_dp
+     TYPE (pw_pool_p_type), DIMENSION(:), POINTER :: pw_pools
+     TYPE (pw_grid_type), POINTER                 :: mt_super_ref_pw_grid
+     TYPE (ps_implicit_type), POINTER             :: implicit_env
+     TYPE (pw_grid_type), POINTER                 :: dct_pw_grid
+     TYPE (pw_grid_type), POINTER                 :: dct_aux_pw_grid
+     TYPE (realspace_grid_type), POINTER          :: diel_rs_grid
   END TYPE pw_poisson_type
 
 ! *****************************************************************************
@@ -145,6 +168,7 @@
      REAL (KIND=dp) :: sr_alpha
      REAL (KIND=dp) :: sr_rc
      TYPE ( pw_type ), POINTER :: influence_fn
+     TYPE ( pw_type ), POINTER :: dct_influence_fn
      TYPE ( pw_type ), POINTER :: screen_fn
      TYPE ( pw_type ), POINTER :: p3m_charge
   END TYPE greens_fn_type
@@ -161,18 +185,20 @@
 !> \param cell_hmat ...
 !> \param pw_pool ...
 !> \param mt_super_ref_pw_grid ...
+!> \param dct_pw_grid ...
 !> \param error ...
 !> \author Fawzi, based on previous functions by JGH and Teo
 ! *****************************************************************************
   SUBROUTINE pw_green_create ( green, poisson_params, cell_hmat, pw_pool, &
-       mt_super_ref_pw_grid, error )
+       mt_super_ref_pw_grid, dct_pw_grid, error )
     TYPE(greens_fn_type), POINTER            :: green
     TYPE(pw_poisson_parameter_type), &
       INTENT(IN)                             :: poisson_params
     REAL(KIND=dp), DIMENSION(3, 3), &
       INTENT(IN)                             :: cell_hmat
     TYPE(pw_pool_type), POINTER              :: pw_pool
-    TYPE(pw_grid_type), POINTER              :: mt_super_ref_pw_grid
+    TYPE(pw_grid_type), POINTER              :: mt_super_ref_pw_grid, &
+                                                dct_pw_grid
     TYPE(cp_error_type), INTENT(inout)       :: error
 
     CHARACTER(len=*), PARAMETER :: routineN = 'pw_green_create', &
@@ -185,8 +211,9 @@
                                                 j1g, k0g, k1g, rlength, &
                                                 zlength
     REAL(KIND=dp), DIMENSION(3)              :: abc
-    TYPE(pw_grid_type), POINTER              :: grid
-    TYPE(pw_type), POINTER                   :: gf
+    TYPE(pw_grid_type), POINTER              :: dct_grid, grid
+    TYPE(pw_pool_type), POINTER              :: pw_pool_xpndd
+    TYPE(pw_type), POINTER                   :: dct_gf, gf
 
     failure = .FALSE.
     CPPrecondition(.NOT.(ASSOCIATED(green)),cp_failure_level,routineP,error,failure)
@@ -215,6 +242,7 @@
 
        NULLIFY (green%influence_fn,green%p3m_charge)
        NULLIFY (green%p3m_coeff,green%p3m_bm2)
+       NULLIFY (green%dct_influence_fn)
        NULLIFY (green%screen_fn)
 
        !CPPrecondition(cell%orthorhombic,cp_failure_level,routineP,error,failure)
@@ -289,15 +317,19 @@
           CASE DEFAULT
              CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
           END SELECT
+       CASE (pw_poisson_implicit)
+          green%method = PS_IMPLICIT
        CASE DEFAULT
           CALL cp_assert(.FALSE.,cp_failure_level,cp_assertion_failed,routineP,&
                "An unknown Poisson solver was specified",error,failure)
        END SELECT
+
        ! allocate influence function,...
        SELECT CASE ( green % method )
-       CASE ( PERIODIC3D, ANALYTIC2D, ANALYTIC1D, ANALYTIC0D, MT2D, MT1D, MT0D, MULTIPOLE0D)
+       CASE ( PERIODIC3D, ANALYTIC2D, ANALYTIC1D, ANALYTIC0D, MT2D, MT1D, MT0D, MULTIPOLE0D, PS_IMPLICIT )
           CALL pw_pool_create_pw ( pw_pool, green % influence_fn,&
                use_data=COMPLEXDATA1D, in_space=RECIPROCALSPACE ,error=error)
+
           IF (poisson_params%ewald_type==do_ewald_spme) THEN
              green%p3m = .TRUE.
              green%p3m_order = poisson_params%ewald_o_spline
@@ -320,7 +352,15 @@
                   alpha=green%MT_alpha, &
                   special_dimension=green%special_dimension, slab_size=green%slab_size, &
                   super_ref_pw_grid=mt_super_ref_pw_grid, error=error)
+          CASE(PS_IMPLICIT)
+             IF (poisson_params%ps_implicit_params%boundary_condition .EQ. MIXED_BC) THEN
+                CALL pw_pool_create(pw_pool_xpndd, pw_grid=dct_pw_grid, error=error)
+                CALL pw_pool_create_pw(pw_pool_xpndd, green%dct_influence_fn, &
+                     use_data=COMPLEXDATA1D, in_space=RECIPROCALSPACE, error=error)
+                CALL pw_pool_release(pw_pool_xpndd, error=error)
+             END IF
           END SELECT
+
        CASE DEFAULT
           CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
        END SELECT
@@ -330,6 +370,7 @@
        grid => green % influence_fn % pw_grid
        SELECT CASE ( green%method )
        CASE ( PERIODIC3D, MULTIPOLE0D )
+
           DO ig = grid % first_gne0, grid % ngpts_cut_local
              g2 = grid % gsq ( ig )
              gf % cc ( ig ) = fourpi / g2
@@ -387,6 +428,7 @@
                gf % cc ( 1 ) = 0.5_dp * fourpi * rlength * rlength
 
        CASE ( MT2D, MT1D, MT0D )
+
           DO ig = grid % first_gne0, grid % ngpts_cut_local
              g2 = grid % gsq ( ig )
              g3d = fourpi / g2
@@ -394,6 +436,26 @@
           END DO
           IF ( grid % have_g0 ) &
                gf%cc(1) = green%screen_fn%cc(1)
+
+       CASE ( PS_IMPLICIT )
+
+          DO ig = grid % first_gne0, grid % ngpts_cut_local
+             g2 = grid % gsq ( ig )
+             gf % cc ( ig ) = fourpi / g2
+          END DO
+          IF ( grid % have_g0 ) gf % cc ( 1 ) = 0.0_dp
+
+          IF (ASSOCIATED(green % dct_influence_fn)) THEN
+             dct_gf   => green % dct_influence_fn
+             dct_grid => green % dct_influence_fn % pw_grid
+
+             DO ig = dct_grid % first_gne0, dct_grid % ngpts_cut_local
+                g2 = dct_grid % gsq ( ig )
+                dct_gf % cc ( ig ) = fourpi / g2
+             END DO
+             IF ( dct_grid % have_g0 ) dct_gf % cc ( 1 ) = 0.0_dp
+          END IF
+
        CASE DEFAULT
           CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
        END SELECT
@@ -457,12 +519,15 @@
              IF (can_give_back) THEN
                 CALL pw_pool_give_back_pw(pw_pool,gftype%influence_fn,&
                      accept_non_compatible=.TRUE.,error=error)
+                CALL pw_pool_give_back_pw(pw_pool,gftype%dct_influence_fn,&
+                     accept_non_compatible=.TRUE.,error=error)
                 CALL pw_pool_give_back_pw(pw_pool,gftype%screen_fn,&
                      accept_non_compatible=.TRUE.,error=error)
                 CALL pw_pool_give_back_pw(pw_pool,gftype%p3m_charge,&
                      accept_non_compatible=.TRUE.,error=error)
              ELSE
                 CALL pw_release(gftype%influence_fn,error=error)
+                CALL pw_release(gftype%dct_influence_fn,error=error)
                 CALL pw_release(gftype%screen_fn,error=error)
                 CALL pw_release(gftype % p3m_charge, error=error)
              END IF
@@ -623,8 +688,13 @@
        poisson_env%method=pw_poisson_none
        poisson_env%rebuild=.TRUE.
        NULLIFY(poisson_env%green_fft,&
-            poisson_env%pw_pools,poisson_env%green_fft,&
-            poisson_env%mt_super_ref_pw_grid,poisson_env%wavelet)
+            poisson_env%pw_pools,&
+            poisson_env%mt_super_ref_pw_grid,&
+            poisson_env%wavelet,&
+            poisson_env%implicit_env,&
+            poisson_env%dct_pw_grid,&
+            poisson_env%dct_aux_pw_grid,&
+            poisson_env%diel_rs_grid)
        poisson_env%pw_level=-1
        poisson_env%ref_count=1
     END IF
@@ -683,11 +753,17 @@
           IF (ASSOCIATED(poisson_env%pw_pools)) THEN
              CALL pw_pools_dealloc(poisson_env%pw_pools,error=error)
           END IF
+
           CALL pw_green_release(poisson_env%green_fft,error=error)
           CALL pw_grid_release(poisson_env%mt_super_ref_pw_grid,error=error)
           CALL ps_wavelet_release(poisson_env%wavelet,error=error)
+          CALL ps_implicit_release(poisson_env%implicit_env,error=error)
+          CALL pw_grid_release(poisson_env%dct_pw_grid,error=error)
+          CALL pw_grid_release(poisson_env%dct_aux_pw_grid,error=error)
+          CALL rs_grid_release(poisson_env%diel_rs_grid,error=error)
           DEALLOCATE(poisson_env,stat=stat)
           CPPostconditionNoFail(stat==0,cp_warning_level,routineP,error)
+
        END IF
     END IF
     NULLIFY(poisson_env)
Index: qs_ks_methods.F
===================================================================
--- qs_ks_methods.F	(revision 14892)
+++ qs_ks_methods.F	(working copy)
@@ -80,6 +80,7 @@
   USE lri_forces,                      ONLY: calculate_lri_forces
   USE lri_ks_methods,                  ONLY: calculate_lri_ks_matrix
   USE message_passing,                 ONLY: mp_sum
+  USE pw_env_methods
   USE pw_env_types,                    ONLY: pw_env_get,&
                                              pw_env_type
   USE pw_methods,                      ONLY: pw_axpy,&
@@ -237,7 +238,8 @@
                                                 v_rspace_new_aux_fit, &
                                                 v_tau_rspace, &
                                                 v_tau_rspace_aux_fit
-    TYPE(pw_p_type), POINTER                 :: rho_nlcc, vee, vppl_rspace
+    TYPE(pw_p_type), POINTER                 :: rho_core, rho_nlcc, vee, &
+                                                vppl_rspace
     TYPE(pw_poisson_type), POINTER           :: poisson_env
     TYPE(pw_pool_p_type), DIMENSION(:), &
       POINTER                                :: pw_pools
@@ -261,7 +263,7 @@
          matrix_vxc, matrix_ks_aux_fit, matrix_ks_aux_fit_im, &
          matrix_ks_aux_fit_dft,&
          matrix_s_aux_fit, matrix_s_aux_fit_vs_orb, vee, rho_nlcc, ks_env, &
-         ks_matrix, ks_matrix_im, rho, energy, rho_xc, rho_r, rho_ao)
+         ks_matrix, ks_matrix_im, rho, energy, rho_xc, rho_r, rho_ao, rho_core)
 
     CPPrecondition(ASSOCIATED(qs_env),cp_failure_level,routineP,error,failure)
 
@@ -292,6 +294,7 @@
                     vee=vee,&
                     rho_nlcc=rho_nlcc,&
                     rho=rho,&
+                    rho_core=rho_core,&
                     rho_xc=rho_xc,&
                     energy=energy,&
                     error=error)
@@ -421,8 +424,8 @@
                                    v_hartree_gspace%pw,h_stress=h_stress,error=error)
              virial%pv_virial = virial%pv_virial + h_stress/REAL(para_env%num_pe,dp)
           ELSE
-             CALL pw_poisson_solve(poisson_env,rho_tot_gspace%pw,energy%hartree,&
-                                   v_hartree_gspace%pw,error=error)
+             CALL pw_poisson_solve(poisson_env, rho_tot_gspace%pw,energy%hartree, &
+                              v_hartree_gspace%pw, rho_core=rho_core, error=error)
           END IF
        END IF
 
