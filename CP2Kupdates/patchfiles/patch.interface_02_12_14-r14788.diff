Index: dm_ls_scf.F
===================================================================
--- dm_ls_scf.F	(revision 14788)
+++ dm_ls_scf.F	(working copy)
@@ -24,7 +24,8 @@
        cp_dbcsr_create, cp_dbcsr_distribution, cp_dbcsr_filter, &
        cp_dbcsr_frobenius_norm, cp_dbcsr_get_occupation, cp_dbcsr_init, &
        cp_dbcsr_multiply, cp_dbcsr_p_type, cp_dbcsr_release, cp_dbcsr_scale, &
-       cp_dbcsr_set, cp_dbcsr_type, dbcsr_type_no_symmetry
+       cp_dbcsr_set, cp_dbcsr_type, dbcsr_type_no_symmetry, cp_dbcsr_name, &
+       cp_dbcsr_get_matrix_type, cp_dbcsr_desymmetrize, cp_dbcsr_convert_to_block_row_distributed
   USE cp_dbcsr_util,                   ONLY: lanczos_alg_serial
   USE cp_external_control,             ONLY: external_control
   USE cp_para_env,                     ONLY: cp_para_env_retain
@@ -78,6 +79,13 @@
                                              write_mo_free_results
   USE timings,                         ONLY: timeset,&
                                              timestop
+  USE c_dbcsr_types
+  USE c_dbcsr_methods
+  USE transport
+  USE transport_types,                 ONLY: c_transport_type,&
+                                             transport_type
+  USE, INTRINSIC :: ISO_C_BINDING
+
 #include "./common/cp_common_uses.f90"
 
   IMPLICIT NONE
@@ -835,7 +843,7 @@
                                                 nelectron_spin_real, nmixing, &
                                                 nspin, unit_nr
     LOGICAL                                  :: check_convergence, diis_step, &
-                                                should_stop
+                                                do_transport, should_stop
     REAL(KIND=dp)                            :: energy_diff, energy_new, &
                                                 energy_old, eps_diis, t1, t2
     TYPE(cp_dbcsr_p_type), DIMENSION(:), &
@@ -846,6 +854,8 @@
     TYPE(cp_logger_type), POINTER            :: logger
     TYPE(qs_diis_buffer_type_sparse), &
       POINTER                                :: diis_buffer
+    TYPE(section_vals_type), POINTER         :: transport_section
+    TYPE(transport_type), POINTER            :: transport_env
 
     CALL timeset(routineN,handle)
 
@@ -889,6 +899,12 @@
      CALL qs_diis_b_clear_sparse(diis_buffer,error=error)
      CALL get_qs_env(qs_env,matrix_s=matrix_s,error=error)
     END IF
+
+! transport ... note: get do_transport from qs_env instead of here
+    CALL get_qs_env(qs_env, transport_env=transport_env, error=error)
+    transport_section => section_vals_get_subs_vals(qs_env%input,"DFT%TRANSPORT",error=error)
+    CALL section_vals_get(transport_section,explicit=do_transport,error=error)
+
     ! the real SCF loop
     DO
 
@@ -912,109 +928,151 @@
          ENDIF
          CALL cp_dbcsr_filter(ls_scf_env%matrix_ks(ispin),ls_scf_env%eps_filter,error=error)
       ENDDO
-      ! run curvy steps if required. Needs an idempotent DM (either perification or restart)
-      IF((iscf>1.OR.ls_scf_env%scf_history%istore>0).AND.ls_scf_env%curvy_steps)THEN
-         CALL dm_ls_curvy_optimization(ls_scf_env,energy_old,check_convergence,error)
-      ELSE
-         ! turn the KS matrix in a density matrix
+!the sparsity has changed here get a matrix from qs_env and copy ks to it for s i don't have to do this
+      IF (do_transport) THEN
+!         IF (ls_scf_env%has_s_preconditioner) STOP "NOT YET IMPLEMENTED"
          DO ispin=1,nspin
             IF (iscf==1) THEN
                ! initialize the mixing matrix with the current state if needed
                CALL cp_dbcsr_copy(matrix_mixing_old(ispin), ls_scf_env%matrix_ks(ispin), error=error)
             ELSE
-             IF (ls_scf_env%ls_diis) THEN ! ------- IF-DIIS+MIX--- START
-              IF (diis_step.and.(iscf-1).ge.ls_scf_env%iter_ini_diis) THEN
                IF (unit_nr>0) THEN
-                WRITE(unit_nr,'(A61)') &
-                       '*************************************************************'
-                WRITE(unit_nr,'(A50,2(I3,A1),L1,A1)') &
-                       " Using DIIS mixed KS:  (iscf,INI_DIIS,DIIS_STEP)=(" , &
-                       iscf,",",ls_scf_env%iter_ini_diis,",",diis_step,")"
-                WRITE(unit_nr,'(A52)') &
-                       " KS_nw= DIIS-Linear-Combination-Previous KS matrices"
-                WRITE(unit_nr,'(61A)') &
-                       "*************************************************************"
+                  WRITE(unit_nr,'(A57)') &
+                       "*********************************************************"
+                  WRITE(unit_nr,'(A23,F5.3,A25,I3)') &
+                       " Using MIXING_FRACTION=", ls_scf_env%mixing_fraction, &
+                       " to mix KS matrix:  iscf=",iscf
+                  WRITE(unit_nr,'(A7,F5.3,A6,F5.3,A7)') &
+                       " KS_nw=",ls_scf_env%mixing_fraction,"*KS + ", &
+                       1.0_dp-ls_scf_env%mixing_fraction,"*KS_old"
+                  WRITE(unit_nr,'(A57)') &
+                       "*********************************************************"
                ENDIF
-               CALL cp_dbcsr_copy(matrix_mixing_old(ispin),   & ! out
-                                  ls_scf_env%matrix_ks(ispin),& ! in
-                                  error=error)
-              ELSE
-               IF (unit_nr>0) THEN
-                WRITE(unit_nr,'(A57)') &
-                      "*********************************************************"
-                WRITE(unit_nr,'(A23,F5.3,A25,I3)') &
-                      " Using MIXING_FRACTION=",ls_scf_env%mixing_fraction, &
-                      " to mix KS matrix:  iscf=",iscf 
-                WRITE(unit_nr,'(A7,F5.3,A6,F5.3,A7)') &
-                      " KS_nw=",ls_scf_env%mixing_fraction,"*KS + ", &
-                      1.0_dp-ls_scf_env%mixing_fraction,"*KS_old"
-                WRITE(unit_nr,'(A57)') &
-                      "*********************************************************"
-               ENDIF
                ! perform the mixing of ks matrices
-               CALL cp_dbcsr_add(matrix_mixing_old(ispin)   ,       &
-                                 ls_scf_env%matrix_ks(ispin),       &
-                                 1.0_dp-ls_scf_env%mixing_fraction, &
-                                 ls_scf_env%mixing_fraction,        &
+               CALL cp_dbcsr_add(matrix_mixing_old(ispin), ls_scf_env%matrix_ks(ispin), &
+                                 1.0_dp-ls_scf_env%mixing_fraction,ls_scf_env%mixing_fraction, &
                                  error=error)
-              ENDIF
-             ELSE ! otherwise
-               IF (unit_nr>0) THEN
-                WRITE(unit_nr,'(A57)') &
-                      "*********************************************************"
-                WRITE(unit_nr,'(A23,F5.3,A25,I3)') &
-                      " Using MIXING_FRACTION=", ls_scf_env%mixing_fraction, &
-                      " to mix KS matrix:  iscf=",iscf
-                WRITE(unit_nr,'(A7,F5.3,A6,F5.3,A7)') &
-                      " KS_nw=",ls_scf_env%mixing_fraction,"*KS + ", &
-                      1.0_dp-ls_scf_env%mixing_fraction,"*KS_old"
-                WRITE(unit_nr,'(A57)') &
-                      "*********************************************************"
-               ENDIF
-               ! perform the mixing of ks matrices
-               CALL cp_dbcsr_add(matrix_mixing_old(ispin)   ,       &
-                                 ls_scf_env%matrix_ks(ispin),       &
-                                 1.0_dp-ls_scf_env%mixing_fraction, &
-                                 ls_scf_env%mixing_fraction,        &
-                                 error=error)
-             ENDIF ! ------- IF-DIIS+MIX--- END
             ENDIF
 
-            ! compute the density matrix that matches it
-            ! we need the proper number of states
             nelectron_spin_real=ls_scf_env%nelectron_spin(ispin)
             IF (ls_scf_env%nspins==1) nelectron_spin_real=nelectron_spin_real/2
 
-            SELECT CASE(ls_scf_env%purification_method)
-            CASE(ls_scf_ns)
-              CALL density_matrix_sign(ls_scf_env%matrix_p(ispin),ls_scf_env%mu_spin(ispin), ls_scf_env%fixed_mu, &
-                                       matrix_mixing_old(ispin),ls_scf_env%matrix_s, ls_scf_env%matrix_s_inv, &
-                                       nelectron_spin_real,ls_scf_env%eps_filter,error)
-            CASE(ls_scf_tc2)
-              CALL density_matrix_tc2(ls_scf_env%matrix_p(ispin), matrix_mixing_old(ispin),  ls_scf_env%matrix_s_sqrt_inv,&
-                                       nelectron_spin_real, ls_scf_env%eps_filter, ls_scf_env%homo_spin(ispin),&
-                                       ls_scf_env%lumo_spin(ispin), non_monotonic=ls_scf_env%non_monotonic, &
-                                       eps_lanczos=ls_scf_env%eps_lanczos, max_iter_lanczos=ls_scf_env%max_iter_lanczos,&
-                                       error=error)
-            CASE(ls_scf_trs4)
-              CALL density_matrix_trs4(ls_scf_env%matrix_p(ispin), matrix_mixing_old(ispin),  ls_scf_env%matrix_s_sqrt_inv,&
-                                       nelectron_spin_real, ls_scf_env%eps_filter, ls_scf_env%homo_spin(ispin),&
-                                       ls_scf_env%lumo_spin(ispin), ls_scf_env%mu_spin(ispin), &
-                                       dynamic_threshold=ls_scf_env%dynamic_threshold,&
-                                       matrix_ks_deviation=matrix_ks_deviation(ispin), &
-                                       eps_lanczos=ls_scf_env%eps_lanczos, max_iter_lanczos=ls_scf_env%max_iter_lanczos,&
-                                       error=error)
-            END SELECT
-                                     
-            IF (ls_scf_env%has_s_preconditioner) THEN
-                CALL apply_matrix_preconditioner(ls_scf_env%matrix_p(ispin),"forward", &
-                               ls_scf_env%matrix_bs_sqrt,ls_scf_env%matrix_bs_sqrt_inv,error)
-            ENDIF
-            CALL cp_dbcsr_filter(ls_scf_env%matrix_p(ispin),ls_scf_env%eps_filter,error=error)
+            ! input the current kohn sham matrix (ks) output matrix_p and should_stop
+            CALL external_scf_method(transport_env, ls_scf_env%matrix_s, matrix_mixing_old(ispin), &
+                                     ls_scf_env%matrix_p(ispin), nelectron_spin_real, ls_scf_env%natoms, error)
+
+!            IF (ls_scf_env%has_s_preconditioner) THEN
+!                CALL apply_matrix_preconditioner(ls_scf_env%matrix_p(ispin),"forward", &
+!                               ls_scf_env%matrix_bs_sqrt,ls_scf_env%matrix_bs_sqrt_inv,error)
+!            ENDIF
+
+            IF (ls_scf_env%nspins==1) CALL cp_dbcsr_scale(ls_scf_env%matrix_p(ispin),2.0_dp,error=error)
+         END DO
+      ELSE
+         ! run curvy steps if required. Needs an idempotent DM (either perification or restart)
+         IF((iscf>1.OR.ls_scf_env%scf_history%istore>0).AND.ls_scf_env%curvy_steps)THEN
+            CALL dm_ls_curvy_optimization(ls_scf_env,energy_old,check_convergence,error)
+         ELSE
+            ! turn the KS matrix in a density matrix
+            DO ispin=1,nspin
+               IF (iscf==1) THEN
+                  ! initialize the mixing matrix with the current state if needed
+                  CALL cp_dbcsr_copy(matrix_mixing_old(ispin), ls_scf_env%matrix_ks(ispin), error=error)
+               ELSE
+                IF (ls_scf_env%ls_diis) THEN ! ------- IF-DIIS+MIX--- START
+                 IF (diis_step.and.(iscf-1).ge.ls_scf_env%iter_ini_diis) THEN
+                  IF (unit_nr>0) THEN
+                   WRITE(unit_nr,'(A61)') &
+                          '*************************************************************'
+                   WRITE(unit_nr,'(A50,2(I3,A1),L1,A1)') &
+                          " Using DIIS mixed KS:  (iscf,INI_DIIS,DIIS_STEP)=(" , &
+                          iscf,",",ls_scf_env%iter_ini_diis,",",diis_step,")"
+                   WRITE(unit_nr,'(A52)') &
+                          " KS_nw= DIIS-Linear-Combination-Previous KS matrices"
+                   WRITE(unit_nr,'(61A)') &
+                          "*************************************************************"
+                  ENDIF
+                  CALL cp_dbcsr_copy(matrix_mixing_old(ispin),   & ! out
+                                     ls_scf_env%matrix_ks(ispin),& ! in
+                                     error=error)
+                 ELSE
+                  IF (unit_nr>0) THEN
+                   WRITE(unit_nr,'(A57)') &
+                         "*********************************************************"
+                   WRITE(unit_nr,'(A23,F5.3,A25,I3)') &
+                         " Using MIXING_FRACTION=",ls_scf_env%mixing_fraction, &
+                         " to mix KS matrix:  iscf=",iscf 
+                   WRITE(unit_nr,'(A7,F5.3,A6,F5.3,A7)') &
+                         " KS_nw=",ls_scf_env%mixing_fraction,"*KS + ", &
+                         1.0_dp-ls_scf_env%mixing_fraction,"*KS_old"
+                   WRITE(unit_nr,'(A57)') &
+                         "*********************************************************"
+                  ENDIF
+                  ! perform the mixing of ks matrices
+                  CALL cp_dbcsr_add(matrix_mixing_old(ispin)   ,       &
+                                    ls_scf_env%matrix_ks(ispin),       &
+                                    1.0_dp-ls_scf_env%mixing_fraction, &
+                                    ls_scf_env%mixing_fraction,        &
+                                    error=error)
+                 ENDIF
+                ELSE ! otherwise
+                  IF (unit_nr>0) THEN
+                   WRITE(unit_nr,'(A57)') &
+                         "*********************************************************"
+                   WRITE(unit_nr,'(A23,F5.3,A25,I3)') &
+                         " Using MIXING_FRACTION=", ls_scf_env%mixing_fraction, &
+                         " to mix KS matrix:  iscf=",iscf
+                   WRITE(unit_nr,'(A7,F5.3,A6,F5.3,A7)') &
+                         " KS_nw=",ls_scf_env%mixing_fraction,"*KS + ", &
+                         1.0_dp-ls_scf_env%mixing_fraction,"*KS_old"
+                   WRITE(unit_nr,'(A57)') &
+                         "*********************************************************"
+                  ENDIF
+                  ! perform the mixing of ks matrices
+                  CALL cp_dbcsr_add(matrix_mixing_old(ispin)   ,       &
+                                    ls_scf_env%matrix_ks(ispin),       &
+                                    1.0_dp-ls_scf_env%mixing_fraction, &
+                                    ls_scf_env%mixing_fraction,        &
+                                    error=error)
+                ENDIF ! ------- IF-DIIS+MIX--- END
+               ENDIF
    
-            IF (ls_scf_env%nspins==1) CALL cp_dbcsr_scale(ls_scf_env%matrix_p(ispin),2.0_dp,error=error)
-
-         ENDDO
+               ! compute the density matrix that matches it
+               ! we need the proper number of states
+               nelectron_spin_real=ls_scf_env%nelectron_spin(ispin)
+               IF (ls_scf_env%nspins==1) nelectron_spin_real=nelectron_spin_real/2
+   
+               SELECT CASE(ls_scf_env%purification_method)
+               CASE(ls_scf_ns)
+                 CALL density_matrix_sign(ls_scf_env%matrix_p(ispin),ls_scf_env%mu_spin(ispin), ls_scf_env%fixed_mu, &
+                                          matrix_mixing_old(ispin),ls_scf_env%matrix_s, ls_scf_env%matrix_s_inv, &
+                                          nelectron_spin_real,ls_scf_env%eps_filter,error)
+               CASE(ls_scf_tc2)
+                 CALL density_matrix_tc2(ls_scf_env%matrix_p(ispin), matrix_mixing_old(ispin),  ls_scf_env%matrix_s_sqrt_inv,&
+                                          nelectron_spin_real, ls_scf_env%eps_filter, ls_scf_env%homo_spin(ispin),&
+                                          ls_scf_env%lumo_spin(ispin), non_monotonic=ls_scf_env%non_monotonic, &
+                                          eps_lanczos=ls_scf_env%eps_lanczos, max_iter_lanczos=ls_scf_env%max_iter_lanczos,&
+                                          error=error)
+               CASE(ls_scf_trs4)
+                 CALL density_matrix_trs4(ls_scf_env%matrix_p(ispin), matrix_mixing_old(ispin),  ls_scf_env%matrix_s_sqrt_inv,&
+                                          nelectron_spin_real, ls_scf_env%eps_filter, ls_scf_env%homo_spin(ispin),&
+                                          ls_scf_env%lumo_spin(ispin), ls_scf_env%mu_spin(ispin), &
+                                          dynamic_threshold=ls_scf_env%dynamic_threshold,&
+                                          matrix_ks_deviation=matrix_ks_deviation(ispin), &
+                                          eps_lanczos=ls_scf_env%eps_lanczos, max_iter_lanczos=ls_scf_env%max_iter_lanczos,&
+                                          error=error)
+               END SELECT
+                                        
+               IF (ls_scf_env%has_s_preconditioner) THEN
+                   CALL apply_matrix_preconditioner(ls_scf_env%matrix_p(ispin),"forward", &
+                                  ls_scf_env%matrix_bs_sqrt,ls_scf_env%matrix_bs_sqrt_inv,error)
+               ENDIF
+               CALL cp_dbcsr_filter(ls_scf_env%matrix_p(ispin),ls_scf_env%eps_filter,error=error)
+      
+               IF (ls_scf_env%nspins==1) CALL cp_dbcsr_scale(ls_scf_env%matrix_p(ispin),2.0_dp,error=error)
+   
+            ENDDO
+         END IF
       END IF
 
       ! compute the corresponding new energy KS matrix and new energy
@@ -1529,6 +1587,82 @@
   END SUBROUTINE calculate_w_matrix
 
 ! *****************************************************************************
+!> \brief SCF calcualtion with an externally evaluated density matrix
+!>        (coupling with the quantum transport code OMEN)
+!>
+!> \par History
+!>       2012.12 created [Hossein Bani-Hashemian]
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+   SUBROUTINE external_scf_method(transport_env, matrix_s, matrix_ks, matrix_p, nelectron_spin, natoms, error)
+
+    INTERFACE c_func_interface
+      SUBROUTINE c_scf_routine(c_transport_environment, S_matrix_cDBCSR, KS_matrix_cDBCSR, P_matrix_cDBCSR) bind(C)
+        IMPORT :: C_INT, C_PTR, c_DBCSR, c_transport_type
+        IMPLICIT NONE
+        TYPE(c_transport_type), VALUE, INTENT(IN) :: c_transport_environment
+        TYPE(c_DBCSR), VALUE, INTENT(IN)          :: S_matrix_cDBCSR, KS_matrix_cDBCSR
+        TYPE(c_DBCSR)                             :: P_matrix_cDBCSR
+      END SUBROUTINE c_scf_routine
+    END INTERFACE c_func_interface
+
+    TYPE(cp_dbcsr_type),INTENT(IN)         :: matrix_s, matrix_ks
+    INTEGER, INTENT(IN)                    :: nelectron_spin, natoms
+    TYPE(c_transport_type)                 :: c_transport_env
+    TYPE(cp_error_type), INTENT(INOUT)     :: error
+    TYPE(cp_dbcsr_type),INTENT(INOUT)      :: matrix_p
+    TYPE(cp_error_type)                    :: err
+    TYPE(c_DBCSR)                          :: S_cDBCSR, KS_cDBCSR, P_cDBCSR
+    TYPE(cp_dbcsr_type)                    :: matrix_s_brd, matrix_ks_brd, matrix_s_nosym, matrix_ks_nosym
+    TYPE(cp_dbcsr_type)                    :: matrix_tmp
+    TYPE(cp_logger_type), POINTER          :: logger
+    PROCEDURE(c_scf_routine), POINTER      :: c_method
+    TYPE(transport_type), POINTER          :: transport_env
+    INTEGER :: handle
+
+    CHARACTER(len=*), PARAMETER :: routineN = 'external_scf_method', &
+        routineP = moduleN//':'//routineN
+
+    CALL timeset(routineN,handle)
+
+    logger => cp_error_get_logger(error)
+    CALL C_F_PROCPOINTER(transport_env%ext_c_method_ptr, c_method)
+
+    CALL c_transport_type_init(transport_env, nelectron_spin, natoms, c_transport_env, error)
+
+    CALL cp_dbcsr_init (matrix_s_nosym, error=error)
+    CALL cp_dbcsr_create (matrix_s_nosym, template=matrix_s, matrix_type=dbcsr_type_no_symmetry, error=error)
+    CALL cp_dbcsr_desymmetrize(matrix_s, matrix_s_nosym, error)
+    CALL cp_dbcsr_init (matrix_ks_nosym, error=error)
+    CALL cp_dbcsr_create (matrix_ks_nosym, template=matrix_ks, matrix_type=dbcsr_type_no_symmetry, error=error)
+    CALL cp_dbcsr_desymmetrize(matrix_ks, matrix_ks_nosym, error)
+
+    CALL cp_dbcsr_convert_to_block_row_distributed (matrix_s_nosym, matrix_s_brd, err)
+    CALL cp_dbcsr_convert_to_block_row_distributed (matrix_ks_nosym, matrix_ks_brd, err)
+    CALL cDBCSR_nullify (S_cDBCSR)
+    CALL cDBCSR_nullify (KS_cDBCSR)
+    CALL cDBCSR_new (matrix_s_brd, S_cDBCSR, error)
+    CALL cDBCSR_new (matrix_ks_brd, KS_cDBCSR, error)
+
+    CALL c_method(c_transport_env, S_cDBCSR, KS_cDBCSR, P_cDBCSR)
+
+    CALL cp_dbcsr_init(matrix_tmp,error=error)
+    CALL cDBCSR_to_dbcsr (P_cDBCSR, matrix_tmp, &
+                          cp_dbcsr_name(matrix_p), cp_dbcsr_get_matrix_type(matrix_s_nosym),&
+                          cp_dbcsr_distribution(matrix_s_nosym), error)
+    CALL cp_dbcsr_copy(matrix_p, matrix_tmp, error=error)
+
+    CALL cp_dbcsr_release(matrix_tmp, error=error)
+    CALL cp_dbcsr_release(matrix_s_nosym, error=error)
+    CALL cp_dbcsr_release(matrix_s_brd, error=error)
+    CALL cp_dbcsr_release(matrix_ks_nosym, error=error)
+    CALL cp_dbcsr_release(matrix_ks_brd, error=error)
+
+    CALL timestop(handle)
+
+  END SUBROUTINE external_scf_method
+
+! *****************************************************************************
 !> \brief a place for quick experiments
 !> \param ls_scf_env ...
 !> \param error ...
Index: input_cp2k_dft.F
===================================================================
--- input_cp2k_dft.F	(revision 14788)
+++ input_cp2k_dft.F	(working copy)
@@ -97,6 +97,7 @@
   USE input_cp2k_motion_print,         ONLY: add_format_keyword
   USE input_cp2k_poisson,              ONLY: create_poisson_section
   USE input_cp2k_rsgrid,               ONLY: create_rsgrid_section
+  USE input_cp2k_transport,            ONLY: create_transport_section
   USE input_cp2k_xc,                   ONLY: create_xc_section
   USE input_keyword_types,             ONLY: keyword_create,&
                                              keyword_release,&
@@ -516,6 +517,10 @@
     CALL section_add_subsection(section, subsection, error=error)
     CALL section_release(subsection,error=error)
 
+    CALL create_transport_section(subsection,error)
+    CALL section_add_subsection(section, subsection, error=error)
+    CALL section_release(subsection,error=error)
+
     CALL create_tddfpt_section(subsection,error)
     CALL section_add_subsection(section, subsection, error=error)
     CALL section_release(subsection,error=error)
@@ -2666,6 +2671,13 @@
        CALL section_add_keyword(section,keyword,error=error)
        CALL keyword_release(keyword,error=error)
 
+       CALL keyword_create(keyword, name="TRANSPORT",&
+            description="Perform transport calculations",&
+            usage="TRANSPORT",lone_keyword_l_val=.TRUE.,&
+            default_l_val=.FALSE.,error=error)
+       CALL section_add_keyword(section,keyword,error=error)
+       CALL keyword_release(keyword,error=error)
+
        CALL keyword_create(keyword, name="KG_METHOD",&
             description="Use a Kim-Gordon-like scheme.",&
             usage="KG_METHOD",lone_keyword_l_val=.TRUE.,&
Index: input_constants.F
===================================================================
--- input_constants.F	(revision 14788)
+++ input_constants.F	(working copy)
@@ -841,4 +841,10 @@
   INTEGER, PARAMETER, PUBLIC               :: dispersion_uff=100,&
                                               dispersion_d3 =200
 
+  ! transport section
+  INTEGER, PARAMETER, PUBLIC               :: misc_method=0,&
+                                              scalapack_diagonalization=1,&
+                                              kpoint_integration=2,&
+                                              exper_code=3,&
+                                              do_transport=4
 END MODULE input_constants
Index: dbcsrwrap/cp_dbcsr_interface.F
===================================================================
--- dbcsrwrap/cp_dbcsr_interface.F	(revision 14788)
+++ dbcsrwrap/cp_dbcsr_interface.F	(working copy)
@@ -87,7 +87,8 @@
        has_acc, has_mpi, heap_fill, heap_get_first, heap_new, heap_release, &
        heap_reset_first, heap_t, mm_driver_acc, mm_driver_blas, &
        mm_driver_matmul, mm_driver_smm, mm_name_acc, mm_name_blas, &
-       mm_name_matmul, mm_name_smm, multrec_limit, setup_arnoldi_data, swap
+       mm_name_matmul, mm_name_smm, multrec_limit, setup_arnoldi_data, swap, &
+       dbcsr_fill, dbcsr_convert_to_block_row_distributed, dbcsr_redistribute, dbcsr_get_nze
   USE kinds,                           ONLY: default_string_length,&
                                              dp,&
                                              int_8,&
@@ -229,6 +230,7 @@
   PUBLIC :: csr_type, cp_convert_csr_to_dbcsr, cp_convert_dbcsr_to_csr,&
             cp_csr_create_from_dbcsr, cp_csr_destroy, cp_csr_create,&
             cp_csr_create_nze_row
+  PUBLIC :: cp_dbcsr_get_nze, cp_dbcsr_redistribute, cp_dbcsr_convert_to_block_row_distributed, cp_dbcsr_fill
 
   TYPE cp_dbcsr_p_type
      TYPE(cp_dbcsr_type), POINTER :: matrix
@@ -2612,7 +2614,57 @@
     IF(.NOT.is_there) block(:,:) = 0.0_dp
   END SUBROUTINE cp_dbcsr_add_block_node
 
+  SUBROUTINE cp_dbcsr_fill(dblk, row_p, col_i, blk_p, matrix, error)
 
+    TYPE(cp_dbcsr_type),INTENT(INOUT)        :: matrix
+    TYPE(dbcsr_data_obj), INTENT(IN)         :: dblk
+    INTEGER, DIMENSION(:), INTENT(IN), &
+      POINTER                                :: row_p, col_i, blk_p
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_fill', &
+      routineP = moduleN//':'//routineN
+
+    TYPE(dbcsr_error_type)                   :: dbcsr_error
+
+   CALL dbcsr_fill(dblk, row_p, col_i, blk_p, matrix%matrix, dbcsr_error)
+
+  END SUBROUTINE cp_dbcsr_fill
+
+  SUBROUTINE cp_dbcsr_convert_to_block_row_distributed(matrix, brd_matrix, error)
+    TYPE(cp_dbcsr_type), INTENT(IN)           :: matrix
+    TYPE(cp_dbcsr_type), INTENT(OUT)          :: brd_matrix
+    TYPE(cp_error_type), INTENT(INOUT)        :: error
+
+    CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_convert_to_block_row_distributed', &
+      routineP = moduleN//':'//routineN
+
+    TYPE(dbcsr_error_type)                   :: dbcsr_error
+
+    CALL dbcsr_convert_to_block_row_distributed(matrix%matrix, brd_matrix%matrix, dbcsr_error)
+
+  END SUBROUTINE cp_dbcsr_convert_to_block_row_distributed
+
+  PURE FUNCTION cp_dbcsr_get_nze(matrix) RESULT (num_nze)
+    TYPE(cp_dbcsr_type), INTENT(IN)          :: matrix
+    INTEGER                                  :: num_nze
+    num_nze = dbcsr_get_nze(matrix%matrix)
+  END FUNCTION cp_dbcsr_get_nze
+
+  SUBROUTINE cp_dbcsr_redistribute(matrix, redist, error)
+    TYPE(cp_dbcsr_type), INTENT(IN)          :: matrix
+    TYPE(cp_dbcsr_type), INTENT(INOUT)       :: redist
+    TYPE(cp_error_type), INTENT(INOUT)       :: error
+
+    CHARACTER(LEN=*), PARAMETER :: routineN = 'cp_dbcsr_redistribute', &
+      routineP = moduleN//':'//routineN
+
+    TYPE(dbcsr_error_type)                   :: dbcsr_error
+
+    CALL dbcsr_redistribute(matrix%matrix, redist%matrix, dbcsr_error)
+
+  END SUBROUTINE cp_dbcsr_redistribute
+
 #include "cp_dbcsr_interface_s.f90"
 #include "cp_dbcsr_interface_d.f90"
 #include "cp_dbcsr_interface_c.f90"
Index: qs_environment.F
===================================================================
--- qs_environment.F	(revision 14788)
+++ qs_environment.F	(working copy)
@@ -190,6 +190,7 @@
   USE termination,                     ONLY: stop_program
   USE timings,                         ONLY: timeset,&
                                              timestop
+  USE transport,                       ONLY: transport_env_create
 !  USE xas_control,                     ONLY: write_xas_control
 #include "./common/cp_common_uses.f90"
 
@@ -245,7 +246,7 @@
 
     INTEGER                                  :: ikind, istat, method_id, &
                                                 natom, nkind
-    LOGICAL :: do_et, do_exx, do_hfx, do_hfx_ri, do_kpoints, failure, &
+    LOGICAL :: do_et, do_exx, do_hfx, do_hfx_ri, do_kpoints, do_transport, failure, &
       harris_flag, mp2_present, my_qmmm, qmmm_decoupl, use_ref_cell
     REAL(KIND=dp), DIMENSION(:, :), POINTER  :: rtmat
     TYPE(atomic_kind_type), DIMENSION(:), &
@@ -265,7 +266,8 @@
     TYPE(qs_subsys_type), POINTER            :: subsys
     TYPE(rel_control_type), POINTER          :: rel_control
     TYPE(section_vals_type), POINTER :: dft_section, et_coupling_section, &
-      harris_section, hfx_ri_section, hfx_section, kpoint_section, mp2_section
+      harris_section, hfx_ri_section, hfx_section, kpoint_section, mp2_section, &
+      transport_section
 
     failure = .FALSE.
     NULLIFY(my_cell, my_cell_ref, atomic_kind_set, particle_set, &
@@ -439,6 +441,12 @@
        CALL ls_scf_create(qs_env,error)
     ENDIF
 
+    transport_section => section_vals_get_subs_vals(qs_env%input,"DFT%TRANSPORT",error=error)
+    CALL section_vals_get(transport_section,explicit=do_transport,error=error)
+    IF (do_transport) THEN
+       CALL transport_env_create(qs_env,error)
+    END IF
+
     ! see if we have atomic relativistic corrections
     CALL get_qs_env(qs_env,rel_control=rel_control,error=error)
     IF (rel_control%rel_method /= rel_none) THEN
Index: qs_environment_types.F
===================================================================
--- qs_environment_types.F	(revision 14788)
+++ qs_environment_types.F	(working copy)
@@ -156,6 +156,8 @@
   USE semi_empirical_types,            ONLY: se_taper_release,&
                                              se_taper_type
   USE task_list_types,                 ONLY: task_list_type
+  USE transport_types,                 ONLY: transport_env_release,&
+                                             transport_type
   USE virial_types,                    ONLY: virial_type
   USE wannier_states_types,            ONLY: wannier_centres_type
   USE xas_env_types,                   ONLY: xas_env_release,&
@@ -240,6 +242,7 @@
     INTEGER                                               :: sim_step
     TYPE(ga_environment_type), POINTER                    :: ga_env
     TYPE(ls_scf_env_type), POINTER                        :: ls_scf_env
+    TYPE(transport_type), POINTER                         :: transport_env
     TYPE(cell_type), POINTER                              :: super_cell
     TYPE(mo_set_p_type), DIMENSION(:), POINTER            :: mos, mos_aux_fit
     TYPE(cp_fm_p_type), DIMENSION(:), POINTER             :: mo_derivs_aux_fit
@@ -490,7 +493,7 @@
        lri_env,lri_density,hfx_ri_env,dispersion_env, vee,rho_external,external_vxc,mask,&
        mp2_env,kg_env,WannierCentres,ga_env,atprop,ls_scf_env,v_hartree_rspace,&
        s_mstruct_changed,rho_changed,potential_changed,forces_up_to_date,mscfg_env,&
-       error)
+       transport_env,error)
     TYPE(qs_environment_type), POINTER       :: qs_env
     TYPE(atomic_kind_type), DIMENSION(:), &
       OPTIONAL, POINTER                      :: atomic_kind_set
@@ -648,6 +651,7 @@
       POINTER                                :: ga_env
     TYPE(atprop_type), OPTIONAL, POINTER     :: atprop
     TYPE(ls_scf_env_type), OPTIONAL, POINTER :: ls_scf_env
+    TYPE(transport_type), OPTIONAL, POINTER  :: transport_env
     TYPE(pw_type), OPTIONAL, POINTER         :: v_hartree_rspace
     LOGICAL, OPTIONAL                        :: s_mstruct_changed, &
                                                 rho_changed, &
@@ -716,6 +720,7 @@
     IF (PRESENT(run_rtp)) run_rtp=qs_env%run_rtp
     IF (PRESENT(rtp)) rtp=>qs_env%rtp
     IF (PRESENT(ls_scf_env)) ls_scf_env=>qs_env%ls_scf_env
+    IF (PRESENT(transport_env)) transport_env=>qs_env%transport_env
     IF (PRESENT(mscfg_env)) mscfg_env=>qs_env%molecular_scf_guess_env
 
     IF (PRESENT(rho_atom_set)) &
@@ -857,6 +862,7 @@
     TYPE(cp_error_type), INTENT(inout)       :: error
 
     NULLIFY (qs_env%ls_scf_env)
+    NULLIFY (qs_env%transport_env)
     NULLIFY (qs_env%image_matrix)
     NULLIFY (qs_env%ipiv)
     NULLIFY (qs_env%image_coeff)
@@ -1024,7 +1030,7 @@
        outer_scf_history,outer_scf_ihistory,ep_qs_env,x_data,et_coupling,dftb_potential,&
        scp_env,se_taper,se_store_int_env,se_nddo_mpole,se_nonbond_env,admm_env,ls_scf_env,&
        lri_env,lri_density,hfx_ri_env,dispersion_env,mp2_env,kg_env,WannierCentres,ga_env,&
-       error)
+       transport_env,error)
 
     TYPE(qs_environment_type), POINTER       :: qs_env
     TYPE(cell_type), OPTIONAL, POINTER       :: super_cell
@@ -1104,6 +1110,7 @@
       POINTER                                :: se_nonbond_env
     TYPE(admm_type), OPTIONAL, POINTER       :: admm_env
     TYPE(ls_scf_env_type), OPTIONAL, POINTER :: ls_scf_env
+    TYPE(transport_type), OPTIONAL, POINTER  :: transport_env
     TYPE(lri_environment_type), OPTIONAL, &
       POINTER                                :: lri_env
     TYPE(lri_density_type), OPTIONAL, &
@@ -1147,6 +1154,7 @@
     IF (PRESENT(mos)) qs_env%mos => mos
     IF (PRESENT(mos_aux_fit)) qs_env%mos_aux_fit => mos_aux_fit
     IF (PRESENT(ls_scf_env)) qs_env%ls_scf_env => ls_scf_env
+    IF (PRESENT(transport_env)) qs_env%transport_env => transport_env
     ! if intels checking (-C) complains here, you have rediscovered a bug in the intel
     ! compiler (present in at least 10.0.025). A testcase has been submitted to intel.
     IF (PRESENT(use_harris)) qs_env%use_harris = use_harris
@@ -1457,6 +1465,10 @@
           CALL molecular_scf_guess_env_destroy(qs_env%molecular_scf_guess_env,&
                   error=error)
 
+          IF (ASSOCIATED(qs_env%transport_env)) THEN
+             CALL transport_env_release(qs_env%transport_env,error)
+          ENDIF
+
           !Only if do_xas_calculation
           IF(ASSOCIATED(qs_env%xas_env)) THEN
              CALL xas_env_release(qs_env%xas_env,error=error)
Index: dbcsr/ops/dbcsr_transformations.F
===================================================================
--- dbcsr/ops/dbcsr_transformations.F	(revision 14788)
+++ dbcsr/ops/dbcsr_transformations.F	(working copy)
@@ -17,6 +17,8 @@
   USE array_types,                     ONLY: array_data,&
                                              array_hold,&
                                              array_i1d_obj,&
+                                             array_new,&
+                                             array_nullify,&
                                              array_release
   USE dbcsr_block_access,              ONLY: dbcsr_get_block_p,&
                                              dbcsr_put_block
@@ -42,7 +44,7 @@
        dbcsr_distribution_mp, dbcsr_distribution_ncols, &
        dbcsr_distribution_nlocal_cols, dbcsr_distribution_nlocal_rows, &
        dbcsr_distribution_nrows, dbcsr_distribution_release, &
-       dbcsr_distribution_row_dist
+       dbcsr_distribution_row_dist, dbcsr_distribution_new, dbcsr_distribution_init
   USE dbcsr_dist_operations,           ONLY: dbcsr_get_local_cols,&
                                              dbcsr_get_local_rows,&
                                              dbcsr_get_stored_coordinates,&
@@ -66,15 +68,15 @@
                                              dbcsr_iterator_stop
   USE dbcsr_methods,                   ONLY: &
        dbcsr_col_block_sizes, dbcsr_distribution, dbcsr_get_data_type, &
-       dbcsr_get_matrix_type, dbcsr_has_symmetry, dbcsr_init, &
+       dbcsr_get_matrix_type, dbcsr_has_symmetry, dbcsr_init, dbcsr_name, &
        dbcsr_is_initialized, dbcsr_nblkcols_total, dbcsr_nblkrows_total, &
        dbcsr_nfullcols_total, dbcsr_nfullrows_total, dbcsr_release, &
        dbcsr_row_block_sizes, dbcsr_valid_index
   USE dbcsr_mp_methods,                ONLY: &
-       dbcsr_mp_grid_remove, dbcsr_mp_grid_setup, dbcsr_mp_group, &
+       dbcsr_mp_new, dbcsr_mp_grid_remove, dbcsr_mp_grid_setup, dbcsr_mp_group, &
        dbcsr_mp_has_subgroups, dbcsr_mp_my_col_group, dbcsr_mp_my_row_group, &
        dbcsr_mp_mynode, dbcsr_mp_mypcol, dbcsr_mp_myprow, dbcsr_mp_npcols, &
-       dbcsr_mp_nprows, dbcsr_mp_numnodes, dbcsr_mp_pgrid
+       dbcsr_mp_nprows, dbcsr_mp_numnodes, dbcsr_mp_pgrid, dbcsr_mp_release
   USE dbcsr_mp_operations,             ONLY: dbcsr_allgatherv,&
                                              hybrid_alltoall_any,&
                                              hybrid_alltoall_c1,&
@@ -102,11 +104,13 @@
   USE dbcsr_work_operations,           ONLY: dbcsr_create,&
                                              dbcsr_finalize,&
                                              dbcsr_work_create
-  USE kinds,                           ONLY: dp,&
+  USE kinds,                           ONLY: default_string_length,&
+                                             dp,&
                                              int_8,&
                                              sp
   USE message_passing,                 ONLY: mp_allgather,&
                                              mp_alltoall
+  USE dbcsr_operations,                ONLY: dbcsr_get_info
 
   !$ USE OMP_LIB
 
@@ -123,6 +127,7 @@
             dbcsr_redistribute, dbcsr_make_untransposed_blocks
   PUBLIC :: dbcsr_replicate_all, dbcsr_distribute, dbcsr_datablock_redistribute, dbcsr_replicate
   PUBLIC :: dbcsr_make_dense, dbcsr_make_undense, dbcsr_make_dense_low
+  PUBLIC :: dbcsr_fill, dbcsr_convert_to_block_row_distributed
 
 CONTAINS
 
@@ -2618,4 +2623,318 @@
     END SUBROUTINE cumsum_l
   END SUBROUTINE dbcsr_datablock_redistribute
 
+! *****************************************************************************
+!> \brief Fills a DBCSR matrix with a DBCSR data object.
+!>
+!> \param[in] dblk, row_p, col_i, blk_p, nblks, darea_siz    data area and block
+!>    structure information of the DBCSR matrix to be created
+!> \param[in,out] new_matrix   created DBCSR matrix
+!> \param[in,out] error        error
+!>
+!> \par History
+!>      04.2013 created [Hossein Bani-Hashemian]
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE dbcsr_fill (dblk, row_p, col_i, blk_p, new_matrix, error)
+
+    TYPE(dbcsr_data_obj), INTENT(IN)         :: dblk
+    INTEGER, DIMENSION(:), INTENT(IN), &
+      POINTER                                :: row_p, col_i, blk_p
+    TYPE(dbcsr_obj), INTENT(INOUT)           :: new_matrix
+    TYPE(dbcsr_error_type), INTENT(INOUT)    :: error
+
+    CHARACTER(LEN=*), PARAMETER :: routineN = 'dbcsr_fill', &
+      routineP = moduleN//':'//routineN
+    INTEGER, PARAMETER                       :: metalen = 2
+
+    COMPLEX(KIND=dp), DIMENSION(:), POINTER  :: c_dp
+    COMPLEX(KIND=sp), DIMENSION(:), POINTER  :: c_sp
+    INTEGER :: bcol, blk, blk_ps, blk_size, blks, block_p, brow, col_size, &
+      data_type, dst_p, end_ind, error_handler, meta_l, mp_group, &
+      nblkrows_total, numnodes, row_size, src_p, start_ind, stored_col_new, &
+      stored_row_new
+    INTEGER, ALLOCATABLE, DIMENSION(:)       :: rd_disp, recv_meta, rm_disp, &
+                                                sd_disp, sdp, send_meta, &
+                                                sm_disp, smp
+    INTEGER, ALLOCATABLE, DIMENSION(:, :)    :: recv_count, send_count, &
+                                                total_recv_count, &
+                                                total_send_count
+    INTEGER, DIMENSION(:), POINTER           :: col_blk_size, row_blk_size
+    LOGICAL                                  :: sym_tr, tr
+    REAL(KIND=dp), DIMENSION(:), POINTER     :: r_dp
+    REAL(KIND=sp), DIMENSION(:), POINTER     :: r_sp
+    TYPE(dbcsr_data_obj)                     :: data_block, recv_data, &
+                                                send_data
+    TYPE(dbcsr_distribution_obj)             :: dist
+    TYPE(dbcsr_mp_obj)                       :: mp_env
+
+    CALL dbcsr_error_set(routineN, error_handler, error)
+
+     dist = dbcsr_distribution (new_matrix)
+     mp_env = dbcsr_distribution_mp (dist)
+     numnodes = dbcsr_mp_numnodes (mp_env)
+     mp_group = dbcsr_mp_group (mp_env)
+
+     data_type = dbcsr_get_data_type(new_matrix)
+     nblkrows_total = dbcsr_nblkrows_total(new_matrix)
+     row_blk_size => array_data (new_matrix%m%row_blk_size)
+     col_blk_size => array_data (new_matrix%m%col_blk_size)
+
+     ALLOCATE (send_count(2, 0:numnodes-1))
+     ALLOCATE (recv_count(2, 0:numnodes-1))
+     ALLOCATE (total_send_count(2, 0:numnodes-1))
+     ALLOCATE (total_recv_count(2, 0:numnodes-1))
+     ALLOCATE (sdp(0:numnodes-1))
+     ALLOCATE (sd_disp(0:numnodes-1))
+     ALLOCATE (smp(0:numnodes-1))
+     ALLOCATE (sm_disp(0:numnodes-1))
+     ALLOCATE (rd_disp(0:numnodes-1))
+     ALLOCATE (rm_disp(0:numnodes-1))
+     send_count(:,:) = 0
+     dst_p = -1
+
+     DO brow = 1, nblkrows_total
+        row_size = row_blk_size(brow)
+        DO blk = row_p(brow)+1, row_p(brow+1)
+           bcol = col_i(blk)
+           col_size = col_blk_size(bcol)
+           blk_size = row_size*col_size
+           block_p = ABS(blk_p(blk))
+           sym_tr = .FALSE.
+           CALL dbcsr_get_stored_coordinates (new_matrix%m, brow, bcol, sym_tr, dst_p)
+           send_count(1, dst_p) = send_count(1, dst_p) + 1
+           send_count(2, dst_p) = send_count(2, dst_p) + blk_size
+        END DO
+     END DO
+
+     CALL mp_alltoall(send_count, recv_count, 2, mp_group)
+     CALL dbcsr_data_init (recv_data)
+     CALL dbcsr_data_new (recv_data, data_type, SUM(recv_count(2, :)))
+     ALLOCATE (recv_meta(metalen*SUM(recv_count(1, :))))
+     CALL dbcsr_data_init (send_data)
+     CALL dbcsr_data_new (send_data, data_type, SUM(send_count(2, :)))
+     ALLOCATE (send_meta(metalen*SUM(send_count(1, :))))
+     DO dst_p = 0, numnodes-1
+        total_send_count(1, dst_p) = send_count (1, dst_p)
+        total_send_count(2, dst_p) = send_count (2, dst_p)
+        total_recv_count(1, dst_p) = recv_count (1, dst_p)
+        total_recv_count(2, dst_p) = recv_count (2, dst_p)
+     END DO
+     sd_disp = -1 ; sm_disp = -1 ; rd_disp = -1 ; rm_disp = -1
+     sd_disp(0) = 1 ; sm_disp(0) = 1 ; rd_disp(0) = 1 ; rm_disp(0) = 1
+     DO dst_p = 1, numnodes-1
+        sm_disp(dst_p) = sm_disp(dst_p-1) + metalen*total_send_count(1, dst_p-1)
+        sd_disp(dst_p) = sd_disp(dst_p-1) + total_send_count(2, dst_p-1)
+        rm_disp(dst_p) = rm_disp(dst_p-1) + metalen*total_recv_count(1, dst_p-1)
+        rd_disp(dst_p) = rd_disp(dst_p-1) + total_recv_count(2, dst_p-1)
+     END DO
+     sdp(:) = sd_disp
+     smp(:) = sm_disp - metalen
+
+     SELECT CASE (data_type)
+     CASE (dbcsr_type_real_4)
+          r_sp => dblk%d%r_sp
+     CASE (dbcsr_type_real_8)
+          r_dp => dblk%d%r_dp
+     CASE (dbcsr_type_complex_4)
+          c_sp => dblk%d%c_sp
+     CASE (dbcsr_type_complex_8)
+          c_dp => dblk%d%c_dp
+     END SELECT
+
+     CALL dbcsr_data_init (data_block)
+     CALL dbcsr_data_new (data_block, data_type)
+
+     dst_p = -1
+     DO brow = 1, nblkrows_total
+        row_size = row_blk_size(brow)
+        DO blk = row_p(brow)+1, row_p(brow+1)
+           bcol = col_i(blk)
+           col_size = col_blk_size(bcol)
+           blk_size = row_size*col_size
+           block_p = ABS(blk_p(blk))
+!           block_p = blk_p(blk)
+           sym_tr = .FALSE.
+           CALL dbcsr_get_stored_coordinates(new_matrix%m, brow, bcol, sym_tr, dst_p)
+           smp(dst_p) = smp(dst_p) + metalen
+           start_ind = block_p
+           end_ind = block_p+blk_size-1
+           end_ind = block_p+blk_size-1
+
+           SELECT CASE (data_type)
+           CASE (dbcsr_type_real_4)
+               data_block%d%r_sp => r_sp(start_ind:end_ind)
+           CASE (dbcsr_type_real_8)
+               data_block%d%r_dp => r_dp(start_ind:end_ind)
+           CASE (dbcsr_type_complex_4)
+               data_block%d%c_sp => c_sp(start_ind:end_ind)
+           CASE (dbcsr_type_complex_8)
+               data_block%d%c_dp => c_dp(start_ind:end_ind)
+           END SELECT
+!           tr = block_p .LT. 0
+           tr = .TRUE.
+           IF (tr) THEN
+              send_meta(smp(dst_p)) = -brow
+           ELSE
+               send_meta(smp(dst_p)) = brow
+           END IF
+           send_meta(smp(dst_p)+1) = bcol
+           blk_size = dbcsr_data_get_size (data_block)
+
+           CALL dbcsr_data_set (send_data, lb=sdp(dst_p), data_size=blk_size, src=data_block, source_lb=1)
+           sdp(dst_p) = sdp(dst_p) + blk_size
+        END DO
+     END DO
+
+     SELECT CASE (data_type)
+     CASE (dbcsr_type_real_4)
+        CALL hybrid_alltoall_s1(&
+            send_data%d%r_sp(:), total_send_count(2,:), sd_disp(:)-1,&
+            recv_data%d%r_sp(:), total_recv_count(2,:), rd_disp(:)-1,&
+            mp_env)
+     CASE (dbcsr_type_real_8)
+        CALL hybrid_alltoall_d1 (&
+           send_data%d%r_dp(:), total_send_count(2,:), sd_disp(:)-1,&
+           recv_data%d%r_dp(:), total_recv_count(2,:), rd_disp(:)-1,&
+           mp_env)
+     CASE (dbcsr_type_complex_4)
+        CALL hybrid_alltoall_c1(&
+           send_data%d%c_sp(:), total_send_count(2,:), sd_disp(:)-1,&
+           recv_data%d%c_sp(:), total_recv_count(2,:), rd_disp(:)-1,&
+           mp_env)
+     CASE (dbcsr_type_complex_8)
+        CALL hybrid_alltoall_z1(&
+          send_data%d%c_dp(:), total_send_count(2,:), sd_disp(:)-1,&
+          recv_data%d%c_dp(:), total_recv_count(2,:), rd_disp(:)-1,&
+          mp_env)
+     END SELECT
+     CALL hybrid_alltoall_i1(send_meta(:), metalen*total_send_count(1,:), sm_disp(:)-1,&
+                             recv_meta(:), metalen*total_recv_count(1,:), rm_disp(:)-1, mp_env)
+     CALL dbcsr_work_create(new_matrix,SUM(recv_count(1,:)),&
+                            SUM(recv_count(2,:)), work_mutable=.FALSE., n=1, error=error)
+
+     blk_ps = 1
+     blks = 0
+     DO src_p = 0, numnodes-1
+        DO meta_l = 1, recv_count(1, src_p)
+           brow = recv_meta(rm_disp(src_p)+metalen*(meta_l-1))
+           tr = brow .LT. 0
+           stored_row_new = ABS(brow)
+           stored_col_new = recv_meta(rm_disp(src_p)+metalen*(meta_l-1)+1)
+           blk_size = row_blk_size(stored_row_new) * col_blk_size(stored_col_new)
+
+           data_block = pointer_view (data_block, recv_data, blk_ps, blk_size)
+           CALL dbcsr_put_block(new_matrix, stored_row_new, stored_col_new, data_block, tr)
+
+           blk_ps = blk_ps + blk_size
+           blks = blks + 1
+        END DO
+     END DO
+     CALL dbcsr_data_clear_pointer (data_block)
+     DEALLOCATE (data_block%d)
+     CALL dbcsr_finalize(new_matrix, reshuffle=.TRUE., error=error)
+     CALL dbcsr_data_release (recv_data)
+     CALL dbcsr_data_release (send_data)
+
+     DEALLOCATE(send_count)
+     DEALLOCATE(recv_count)
+     DEALLOCATE(sdp); DEALLOCATE(sd_disp)
+     DEALLOCATE(smp); DEALLOCATE(sm_disp)
+     DEALLOCATE(rd_disp)
+     DEALLOCATE(rm_disp)
+     DEALLOCATE(recv_meta)
+     DEALLOCATE(send_meta)
+
+    CALL dbcsr_error_stop(error_handler, error)
+
+  END SUBROUTINE dbcsr_fill
+
+! *****************************************************************************
+!> \brief Converts a DBCSR matrix into a block row distributed matrix.
+!>
+!> \param[in] dbcsr_mat        DBCSR matrix to be converted
+!> \param[out] brd_mat         converted matrix
+!> \param[in,out] error        error
+!>
+!> \par History
+!>      04.2013 created [Hossein Bani-Hashemian]
+!> \author Mohammad Hossein Bani-Hashemian
+! *****************************************************************************
+  SUBROUTINE dbcsr_convert_to_block_row_distributed (dbcsr_mat, brd_mat, error)
+
+    TYPE(dbcsr_obj), INTENT(IN)              :: dbcsr_mat
+    TYPE(dbcsr_obj), INTENT(OUT)             :: brd_mat
+    TYPE(dbcsr_error_type), INTENT(INOUT)    :: error
+
+    CHARACTER(LEN=*), PARAMETER :: &
+      routineN = 'dbcsr_convert_to_block_row_distributed', &
+      routineP = moduleN//':'//routineN
+
+    CHARACTER                                :: matrix_type
+    CHARACTER(LEN=default_string_length)     :: matrix_name
+    INTEGER :: chunk_size, data_type, error_handler, i, mp_group, mynode, &
+      nblkcols_total, nblkrows_total, num_p, remainder, row_index
+    INTEGER, ALLOCATABLE, DIMENSION(:)       :: cdist, rdist
+    INTEGER, ALLOCATABLE, DIMENSION(:, :)    :: pgrid
+    TYPE(array_i1d_obj)                      :: brd_col_dist, brd_row_dist, &
+                                                col_blk_size, row_blk_size
+    TYPE(dbcsr_distribution_obj)             :: dist_current, dist_new
+    TYPE(dbcsr_mp_obj)                       :: mp_obj_current, mp_obj_new
+
+    CALL dbcsr_error_set(routineN, error_handler, error)
+
+    CALL dbcsr_get_info(dbcsr_mat,nblkrows_total=nblkrows_total,nblkcols_total=nblkcols_total,&
+                        row_blk_size = row_blk_size, col_blk_size = col_blk_size, &
+                        matrix_type = matrix_type, data_type = data_type)
+    matrix_name = dbcsr_name(dbcsr_mat)
+
+    ALLOCATE (rdist(nblkrows_total), cdist(nblkcols_total))
+    CALL array_nullify (brd_row_dist)
+    CALL array_nullify (brd_col_dist)
+
+    dist_current = dbcsr_distribution(dbcsr_mat)
+    mp_obj_current = dbcsr_distribution_mp(dist_current)
+    mp_group = dbcsr_mp_group(mp_obj_current)
+    num_p = dbcsr_mp_numnodes(mp_obj_current)
+    mynode = dbcsr_mp_mynode(mp_obj_current)
+
+    ALLOCATE (pgrid(num_p,1))
+    cdist = 0
+    rdist = 0
+    IF (num_p .GT. nblkrows_total) THEN
+       rdist(:) = (/(i, i = 0, nblkrows_total-1)/)
+    ELSE
+       chunk_size = FLOOR(REAL(nblkrows_total)/num_p)
+       remainder = MOD(nblkrows_total,num_p)
+       row_index = 0
+       DO i = 1, chunk_size*num_p, chunk_size
+         rdist(i:i+chunk_size-1) = row_index
+         row_index = row_index + 1
+       END DO
+       IF (remainder .GT. 0) rdist(chunk_size*num_p+1:nblkrows_total) = row_index-1
+    END IF
+
+    CALL array_new (brd_row_dist, rdist, lb=1)
+    CALL array_new (brd_col_dist, cdist, lb=1)
+    pgrid(:,:) = RESHAPE((/(i, i = 0, num_p-1),0/),(/num_p,1/))
+
+    CALL dbcsr_mp_new(mp_obj_new, pgrid, mp_group, mynode, numnodes=num_p)
+    CALL dbcsr_distribution_init(dist_new)
+    CALL dbcsr_distribution_new(dist_new,mp_obj_new,brd_row_dist,brd_col_dist)
+
+    CALL dbcsr_init(brd_mat)
+    CALL dbcsr_create (brd_mat, TRIM(matrix_name)//" row-block distributed", dist_new, matrix_type, &
+                       row_blk_size, col_blk_size, error=error)
+    CALL dbcsr_complete_redistribute(dbcsr_mat,brd_mat,error=error)
+
+    DEALLOCATE (pgrid)
+    DEALLOCATE (rdist,cdist)
+    CALL array_release(brd_row_dist)
+    CALL array_release(brd_col_dist)
+    CALL dbcsr_mp_release(mp_obj_new)
+    CALL dbcsr_distribution_release(dist_new)
+    CALL dbcsr_error_stop(error_handler, error)
+
+  END SUBROUTINE dbcsr_convert_to_block_row_distributed
+
 END MODULE dbcsr_transformations
Index: dbcsr/dbcsr_api.F
===================================================================
--- dbcsr/dbcsr_api.F	(revision 14788)
+++ dbcsr/dbcsr_api.F	(working copy)
@@ -90,7 +90,7 @@
        dbcsr_max_row_size, dbcsr_name, dbcsr_nblkcols_local, &
        dbcsr_nblkcols_total, dbcsr_nblkrows_local, dbcsr_nblkrows_total, &
        dbcsr_nfullcols_total, dbcsr_nfullrows_total, dbcsr_release, &
-       dbcsr_row_block_sizes, dbcsr_valid_index, dbcsr_wm_use_mutable
+       dbcsr_row_block_sizes, dbcsr_valid_index, dbcsr_wm_use_mutable, dbcsr_get_nze
   USE dbcsr_mp_methods,                ONLY: dbcsr_mp_group,&
                                              dbcsr_mp_hold,&
                                              dbcsr_mp_mynode,&
@@ -118,7 +118,10 @@
                                              dbcsr_distribute,&
                                              dbcsr_new_transposed,&
                                              dbcsr_replicate,&
-                                             dbcsr_replicate_all
+                                             dbcsr_replicate_all,&
+                                             dbcsr_redistribute,&
+                                             dbcsr_fill,&
+                                             dbcsr_convert_to_block_row_distributed
   USE dbcsr_types,                     ONLY: &
        dbcsr_data_obj, dbcsr_distribution_obj, dbcsr_func_artanh, &
        dbcsr_func_dtanh, dbcsr_func_inverse, dbcsr_func_tanh, dbcsr_iterator, &
@@ -368,6 +371,10 @@
             csr_create_template,&
             csr_write,&
             csr_conversion_test,&
-            csr_create_nze_row
+            csr_create_nze_row,&
+            dbcsr_fill,&
+            dbcsr_convert_to_block_row_distributed,&
+            dbcsr_get_nze,&
+            dbcsr_redistribute
 
 END MODULE dbcsr_api
